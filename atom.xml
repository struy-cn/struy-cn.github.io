<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老杨的知识荒原</title>
  
  <subtitle>效率工具、编程技术、阅读感悟；你看到的世界就是你自己的样子！</subtitle>
  <link href="http://struy.cn/atom.xml" rel="self"/>
  
  <link href="http://struy.cn/"/>
  <updated>2023-05-06T05:19:38.631Z</updated>
  <id>http://struy.cn/</id>
  
  <author>
    <name>StruggleYang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工具永远只是工具</title>
    <link href="http://struy.cn/2023/05/06/tool-only-tool/"/>
    <id>http://struy.cn/2023/05/06/tool-only-tool/</id>
    <published>2023-05-06T05:16:14.000Z</published>
    <updated>2023-05-06T05:19:38.631Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做工具分享和探索，总觉得这个工具也牛皮，那个工具也好用，但是慢慢的发现，工具只是为了让我们更好更有效率的工作、学习、创作和生活。但是思考和认知这些底层的血和肉很重要。</p><p>举例子：<br>chatGPT：chatGPT的确很强，我经常用来编写脚本、修改代码或者是查找一些问题的答案。</p><p>他可以作为提高效率的工具，但是首先得有思考，它不能代替我思考。</p><p>我有一个chatGPT账号，但是我能拿他做什么很重要。有他我不会有三头六臂。</p><p>他有无限的知识，那我也能有无限的知识吗？</p><p>还有就是需要分辨信息，这些是需要认知和知识提升才能分辨，多看多学</p><p>抓住领域，深入了解，工具辅助，提升为自我认知。</p><p><img src="https://img.struy.cn/img/202305061318096.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在做工具分享和探索，总觉得这个工具也牛皮，那个工具也好用，但是慢慢的发现，工具只是为了让我们更好更有效率的工作、学习、创作和生活。但是思考和认知这些底层的血和肉很重要。&lt;/p&gt;
&lt;p&gt;举例子：&lt;br&gt;chatGPT：chatGPT的确很强，我经常用来编写脚本、修改代码或</summary>
      
    
    
    
    <category term="认知提升" scheme="http://struy.cn/categories/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
    
    <category term="观点" scheme="http://struy.cn/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>关于有效学习这件事</title>
    <link href="http://struy.cn/2023/05/05/about-effective-learning/"/>
    <id>http://struy.cn/2023/05/05/about-effective-learning/</id>
    <published>2023-05-05T15:00:20.000Z</published>
    <updated>2023-05-06T05:14:45.167Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文摘录自 “卖桃者说”</p></blockquote><p>如何有效地学习？</p><h2 id="意愿"><a href="#意愿" class="headerlink" title="意愿"></a>意愿</h2><p>第一步是要有学习的意愿。如果不想学习，说再多也没用，外界有那么多诱惑，主要还是自控力。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>第二步是要明确学习的目标。如果只是一设定一些宽泛的，比如说就学英语，学为服务这样的含服的目标，大概率半途而废，比如说最近呀。想什么都想，学一点什么chatGPT呀，什么人工智能啊，但这些太大了，学起来很费劲。实力在这里啊。</p><p>那这个学习的目标应该怎么设定最好呢？这里说到就是要在自己日常的工作或者生活中能够用得到，那你学起来可能会更有一些目标和动力。</p><p>嗯，这里发散一下，现在什么都想学，什么都想看一下，信息太混杂了。那我觉得还是要先从工作的内容入手吧，看最近的工作需要学一些什么东西，把这些东西巩固一下。</p><h2 id="实践与目标拆解"><a href="#实践与目标拆解" class="headerlink" title="实践与目标拆解"></a>实践与目标拆解</h2><p>然后就到第三步。第三步就是学了之后怎么去实践。因为如果只学。然后又不不去做的话，那可能就只是停留在想法阶段了，嗯，说实话这种情况很多啊，比如说有个东西学了之后就忘了不去做，也不做个DEMO出来。就光是诶学完感觉嗯还可以，那这样不行，要把它输出出来。这种输出可能有几个方面吧。一种是。分享出去，比如说以文章。然后或者是视频。还有或者是教别人，这样子以教代学可能会更巩固一点。</p><p>然后就是在实践的阶段，有一个很重要的东西，就是拆解目标。如果上来就对着大大目标去搞。可能还没被还没攻控目标的话，就被目标搞怕了，所以目标先搞小一点，从一个小目标再到到目标慢慢的跨越，嗯，这样的效果可能会更好。然后针对每个小目标呢，搞一些。奖励。这种奖励可以刺激多巴胺去分泌，然后让我们更爱上学习，嗯，加加大乐趣。看看电影。吃个饭。或者是买个小东西。还有就是把这个时间固定。比如说早上。早上工作日一般没时间。像这种周末呢，一般。都休息。那工作日那总要留点时间吧，那就下班之后了。这个要规划一下，然后周末呢。周末也要不能完全玩，或者有其他事故处理，要把这个时间留出来，嗯。</p><p>刚才说的。固定时间。这样子有个好处就是。因为有个洋习惯的养成。比如说。这下像每天早上上班。这个时间就是固定的。每天早上我醒的时候。差不多到就是那个点。都不选那种了。所以这个学习如果在固定时间去进行的话，那可能。更好的养成习惯，保持专注。嗯，避免杂食打乱。</p><h2 id="产出与分享"><a href="#产出与分享" class="headerlink" title="产出与分享"></a>产出与分享</h2><p>那上面的三步做完之后呢，这是第四步。就是这些东西啊，不管什么东西啊，学完呀，还要产出。</p><p>就是一个观点是这样说的，就人有生产者和消费者两种角色，如果没有产出的话，只学习本身是一种消费。那每天忙着读书。学习，学这学那，看起来可能很忙，付出了很多，就感觉很努力，很辛苦。但如果没有产出。工作和生活也没有什么改变。那和我们玩会儿手机，看会儿电影，本质上没有太大区别，</p><p>可能就是另一种娱乐，所以一定要产出一些作品，比如说什么呢？解决一个工作中的难题。或者说做出来一些DEMO样例，然后帮别人解决了问题。或者这过程中的思考分享出去。还有就是教别人。像这样子以教代学，然后这样子的话增长更快。总之就是一定要有产出。不要记住答案。要让他们自己去生成的。产出就是自己生成答案的一个过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下有效的学习。四个点。<br>意愿；这个是很重要嘛，没有这说再多都没用了。</p><p>目标；一个细化的目标，然后最好是跟工作生活有关联的目标。</p><p>实践；然后。去把我们的东西付诸实践。在实践阶段，最重要的是拆解目标。</p><p>产出；各种形式都可以。</p><h2 id="语音版-墨问便签"><a href="#语音版-墨问便签" class="headerlink" title="语音版(墨问便签)"></a>语音版(墨问便签)</h2><p><img src="https://img.struy.cn/img/202305061309970.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文摘录自 “卖桃者说”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何有效地学习？&lt;/p&gt;
&lt;h2 id=&quot;意愿&quot;&gt;&lt;a href=&quot;#意愿&quot; class=&quot;headerlink&quot; title=&quot;意愿&quot;&gt;&lt;/a&gt;意愿&lt;/h2&gt;&lt;p&gt;第一步是要有学</summary>
      
    
    
    
    <category term="认知提升" scheme="http://struy.cn/categories/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
    
    <category term="摘录" scheme="http://struy.cn/tags/%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>我看看哪个靓仔还没把Github Copilot用起来?</title>
    <link href="http://struy.cn/2023/04/27/github-copilot-and-labs/"/>
    <id>http://struy.cn/2023/04/27/github-copilot-and-labs/</id>
    <published>2023-04-26T23:20:37.000Z</published>
    <updated>2023-04-27T10:14:00.962Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本人经常分享有价值的生产力工具、技术、好物与书籍，可关注公众号并设为🌟星标，第一时间获得更新</p></blockquote><p><img src="http://img.struy.cn/img/202304212313285.png"></p><p><a href="https://github.com/features/copilot">Github Copilot</a> 是一个AI编程助手，其使用 <a href="https://openai.com/blog/openai-codex/">OpenAI CodeX</a> 在你的编辑器中实时建议代码或给你实现整个功能。</p><span id="more"></span><p><img src="https://img.struy.cn/img/202304271111266.png" alt="Copilot 官网"></p><h2 id="视频版介绍"><a href="#视频版介绍" class="headerlink" title="视频版介绍"></a>视频版介绍</h2><iframe src="//player.bilibili.com/player.html?bvid=BV1em4y1y7cC&page=1&high_quality=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="450" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe><p><a href="https://www.bilibili.com/video/BV1em4y1y7cC">B站视频地址</a></p><h2 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a>Github Copilot</h2><p>比如我让他在 Python 中写一个插入排序，当写完注释按下 TAB 键方法就已经快完成了，多次按下 TAB，验证代码都给你写好了；</p><p><img src="https://img.struy.cn/img/202304271106379.png" alt="Copilot 编写Python代码"></p><p>除了在 Jetbrains 全家桶的 IDE 中使用，还支持大佬们最喜欢的 VScode 中使用</p><p>比如让他在JS中编写一段代码获得 Github 的Top100仓库，TAB几下后便完成了我们的方法。</p><p><img src="https://img.struy.cn/img/202304271108836.png" alt="Copilot JS 代码"></p><h2 id="Github-Copilot-Labs"><a href="#Github-Copilot-Labs" class="headerlink" title="Github Copilot Labs"></a>Github Copilot Labs</h2><p>除了这个关键的插件，VScode上还有个叫 <a href="https://githubnext.com/projects/copilot-labs/">Copilot Labs</a> 的附加插件，它能帮助我们解释翻译代码，生成测试代码、修复bug等快捷操作</p><p><img src="https://img.struy.cn/img/202304271109046.png" alt="Github Copilot Labs 功能"></p><h2 id="不用键盘写代码-Github-Copilot-Voice"><a href="#不用键盘写代码-Github-Copilot-Voice" class="headerlink" title="不用键盘写代码 Github Copilot Voice"></a>不用键盘写代码 Github Copilot Voice</h2><p>另外，Github Next 项目还推出了 <a href="https://githubnext.com/projects/copilot-voice/">Copilot Voice</a> 项目，不用键盘就可以写代码了，可以关注一下。（真一句话需求？）</p><p><img src="https://img.struy.cn/img/202304271115273.png" alt="Github Copilot Voice"></p><h2 id="低成本获得-Github-Copilot-使用"><a href="#低成本获得-Github-Copilot-使用" class="headerlink" title="低成本获得 Github Copilot 使用"></a>低成本获得 Github Copilot 使用</h2><blockquote><p>Copilot 的确方便好用能提高效率，但是官网的价格实在太高了，10美刀一个月，有没有办法以更低的成本获得呢？<br>那肯定有啊，现在联系我一顿饭钱解决，需要的开发大佬可以在评论区留言或者私信我，我来帮助你。赶紧使用起来让编码效率提升吧。</p></blockquote><p><img src="https://img.struy.cn/img/202304271055938.png" alt="解锁 Copilot 权益"></p><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><p><a href="https://mp.weixin.qq.com/s/PEq_9nKKEPEsXWxlF70bhQ">给有需要的开发大佬|公众号</a></p>]]></content>
    
    
    <summary type="html">Github Copilot 是一个AI编程助手，其使用 OpenAI CodeX 在你的编辑器中实时建议代码或给你实现整个功能。本文观看视频更佳</summary>
    
    
    
    <category term="生产力工具" scheme="http://struy.cn/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="AIGC" scheme="http://struy.cn/tags/AIGC/"/>
    
    <category term="Github Copilot" scheme="http://struy.cn/tags/Github-Copilot/"/>
    
    <category term="AI编码" scheme="http://struy.cn/tags/AI%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>本地白嫖AI绘画 ，Stable Diffusion 初探！</title>
    <link href="http://struy.cn/2023/04/19/ai-sd-web-ui-build/"/>
    <id>http://struy.cn/2023/04/19/ai-sd-web-ui-build/</id>
    <published>2023-04-19T06:40:36.000Z</published>
    <updated>2023-04-27T10:16:28.161Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍我在本地搭建 Stable Diffusion Web UI 的体验过程，予以记录分享。</p><span id="more"></span><blockquote><p>Stable Diffusion 是 2022 年 8 发布的深度学习文本到图像生成模型。它主要用于根据文本的描述产生详细图像，官方项目其实并不适合新手直接使用，好在有使用 Stable Diffusion 封装的 WebUI 开源项目，可以通过前端页面来使用 Stable Diffusion，大大降低了使用门槛，本文主要是介绍 Github 作者为 AUTOMATIC1111 的 stable-diffusion-webui；易用，插件丰富。</p></blockquote><blockquote><p>下面可能简称 Stable Diffusion 为 SD。</p></blockquote><h1 id="看看效果"><a href="#看看效果" class="headerlink" title="看看效果"></a>看看效果</h1><p><img src="http://img.struy.cn/img/202304212243150.png"></p><p>▲ 图1-封面，国风模型盲盒</p><table><thead><tr><th>img1</th><th>img2</th><th>img3</th></tr></thead><tbody><tr><td><img src="http://img.struy.cn/img/202304212243799.png"></td><td><img src="http://img.struy.cn/img/202304212244395.png"></td><td><img src="http://img.struy.cn/img/202304212249628.png"></td></tr></tbody></table><p>▲ 组图2，模型 meinamix_meinaV8</p><p><img src="http://img.struy.cn/img/202304212250162.png"></p><p>▲ 图3-生成界面（使用了汉化插件）</p><h1 id="我的环境"><a href="#我的环境" class="headerlink" title="我的环境"></a>我的环境</h1><p>MacBook Pro 14寸</p><p>芯片：Apple M1 Max</p><p>内存：32G</p><p>系统：MacOS 13.3.1</p><p>Python：Python3.8</p><p>出图速度(默认参数下)：快的时候9s，有其他调整的时候稍慢</p><p><img src="http://img.struy.cn/img/202304212251655.png"></p><p>▲ 图4-出图速度</p><h1 id="Stable-Diffusion-Web-UI"><a href="#Stable-Diffusion-Web-UI" class="headerlink" title="Stable Diffusion Web UI"></a>Stable Diffusion Web UI</h1><p><strong>尝试 Docker</strong></p><p>开始准备使用各位大佬推荐的 Docker 搭建，便于一键安装，但是发现无法支持 Mac ，无奈放弃！！！</p><p><img src="http://img.struy.cn/img/202304212252225.png"></p><p>▲ 图5-Docker 安装 FAQ</p><p>如果配置吃得住的 Windows 用户可以试试 Docker 搭建，流程不复杂，直接拉仓库，一键就可以自动安装了，主要使用 docker-compose 进行安装。</p><p>Docker 安装可参考：stable-diffusion-webui-docker [1]</p><p><strong>本地运行 stable-diffusion-webui</strong></p><p>苹果芯片安装文档参考[2]很详细建议看原文档</p><p>这里简单介绍下大致流程：</p><p>1、如果安装了 Homebrew 可以跳过此步，否则需要到 <a href="https://brew.sh/">https://brew.sh</a> 安装Homebrew 便于安装一些必要软件</p><p>2、通过 Homebrew 安装一些必要的程序(由于我本地有 Python 和 Git，所以我安装时去掉了这两个，Python 版本不知道是否有隐患？)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake protobuf rust python@3.10 git wget</span><br></pre></td></tr></table></figure><p>3、将 WebUI 仓库克隆下来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui</span><br></pre></td></tr></table></figure><p>4、下载模型，将 SD 的基础模型（也称之为checkpoint）下载下来放到模型目录stable-diffusion-webui&#x2F;models&#x2F;Stable-diffusion，可直接下载 SD 的官方预训练好的模型先试试，也就是文档中下图所指示位置（下个最新的咯），这个官方模型出图效果一般，可以摸清功能后再去试试其他的模型（关于模型相关的介绍下面会提到）<br><img src="http://img.struy.cn/img/202304212255732.png"></p><p>▲ 图6-模型下载</p><p>如果下载好了模型，接下来执行启动 UI 的命令，他会自动设置好环境，下载所需的一切依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd stable-diffusion-webui</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ./webui.sh</span><br></pre></td></tr></table></figure><p>初次运行期间我遇到的问题主要是下载慢（Github），开一下代理，再次执行启动命令就好了。</p><p>如果是 pip 依赖下载慢，可以尝试切换 pip 源为清华源或者阿里等国内源。</p><p>上面步骤如果都完成能成功启动，在左上角模型选择(参照图3-生成界面)就有模型可以选择。这时试试给一些提示生成图片了 ，可以愉快的玩耍了 🎉。</p><p><img src="http://img.struy.cn/img/202304212256025.png"><br>▲ 左上角则是基模选择项，一次只能使用一种基模</p><p><strong>汉化UI界面</strong></p><p>stable-diffusion-webui-chinese[3]</p><p>看不懂英文没关系，直接装插件汉化一下就 OK 咯：<br><img src="http://img.struy.cn/img/202304212257383.png"></p><h1 id="关于模型"><a href="#关于模型" class="headerlink" title="关于模型"></a>关于模型</h1><p> <strong>在 SD 中，基于训练方式的不同，最常用的两类模型：</strong>本人了解有限，不对的地方恳请指正！<strong>checkpoint ？</strong></p><p>checkpoint 是基础模型，也简称基模，比如上面安装 WebUI 过程中可下载的官方模型就是 SD 预先训练好，是完整模型的常见格式，模型体积较大，一般单个模型的大小在2~7G 左右；模型后缀一般为 .ckpt 或者 .safetensors</p><p>如果下载了 checkpoint，放到 models&#x2F;Stable-diffusion 目录即可</p><p>上面的 <strong>SD 1.5 、SD 2.0、SD 2.1</strong>，有人说 1.5 的模型比 2.x 的模型效果要好？</p><p>下面是一些比较火的三方模型，通常是模型作者基于另外的一些基模（可能是 SD 官方的基模或其他开源的基模）加自己的数据训练出来的模型，一般都是特定风格和一些优化；比如脸型，肤色等等（取决于训练者的数据样本😂）</p><p><code>chilloutmix**[4]**、chilloutmix_NiPrunedFp32Fix**[5]**</code>… 生成真人的模型，由于其生成的图片风格很适合亚洲人，所以在国内应该是最火的模型，下面会给下载链接</p><p><strong>meinamix_meinaV8<code>[6]</code></strong> ，动漫混合型模型，生成的图片多是动漫风格，文中组图2就是其生成</p><p>**GuoFeng3<code>[7]</code><strong>、3Guofeng3_v33</strong><code>[7]</code>**，中国风模型，图1封面图由其生成</p><p><strong>LoRA  ？</strong></p><p>LoRA 模型作用主要是微调，可以理解为在基础模型的前提下，做一些风格增强，因为他固定一些参数和权重，比如有些 lora 模型是专注 亚洲脸调整的参数，有的是古风、动漫风等等不同风格。</p><p>它们通常不会超过 1G，必须与 checkpoint 模型一起使用。</p><p>如果下载了 lora，放到 models&#x2F;Lora 目录即可，随后你可以在界面看到它们，写提示词时，点击对应的 Lora 或按照 <a href="lora:lora模型名:1">lora:lora模型名:1</a> 书写即可使用：</p><p><img src="http://img.struy.cn/img/202304212259312.png"><br><img src="http://img.struy.cn/img/202304212259024.png"></p><p>下面是使用 chilloutmix_NiPrunedFp32Fix 基模+几个 LoRA 在相同提示语下生成的效果，为了区别不同模型的差异，可以给模型设置预览图：</p><p><img src="http://img.struy.cn/img/202304212300808.png"></p><p>▲ 不同 LoRA 在相同提示语下的风格差异便于区别</p><p><strong>怎么区别基础模型 checkpoint 和 Lora？</strong></p><p>比较大的一般就是基础模型（GB级别），其他少于 1G 的一般情况下是 Lora ，毕竟训练量不一样 😂</p><p>一些模型下载网站可能会标识其类型。</p><p>至于其他 VAE、Embedding、Hyperentwork 暂时还不了解。</p><h1 id="模型如何下载"><a href="#模型如何下载" class="headerlink" title="模型如何下载"></a>模型如何下载</h1><p>为了让 AI 绘图更加丰富多样，我们可以下载不同模型多多尝试，包括不限于 checkpoint 和 lora，下面是可以下载到 SD 相关模型文件的地方</p><ul><li><p><strong>飞桨<code>[8]</code></strong></p><p>  百度的飞桨，有些网友会把一些模型分享在上面，下载会快一些，但只有少量 SD 模型被网友传了上去。</p></li></ul><p><img src="http://img.struy.cn/img/202304212301848.png"></p><ul><li><p><strong>huggingface<code>[9]</code></strong></p><p>  很大的模型下载网站，里面包含了方方面面的各类模型。一般推荐在这个网站下载，速度时快时慢（可能是我的网络原因）。</p><p>  <img src="http://img.struy.cn/img/202304212301047.png"></p></li><li><p><strong>civitai</strong> (需科学上网)<strong><code>[10]</code></strong></p><p>  网友简称为C站，上面有很多风格的模型下载，对于每个模型都有图片预览，需要魔法</p></li></ul><p><img src="http://img.struy.cn/img/202304212301426.png"></p><h1 id="提示词怎么写"><a href="#提示词怎么写" class="headerlink" title="提示词怎么写"></a>提示词怎么写</h1><p>发现即使是下载了风格很惊艳的模型，依然无法生成牛逼的图片，那可能需要在提示词上下功夫了，为了让 Stable Diffusion 制作各种惊艳的图，可以直接参考别人的提示词🫡</p><p>以下是一些比较厉害的提示词参考网站，找到喜欢的按照其提示词和参数、Lora 生成即可</p><p>**civitai<code>[10]</code>**：</p><p>上面提到的 C 站，每个模型下面都有对应生成的图片分享，可以摘抄下</p><p><img src="http://img.struy.cn/img/202304212302079.png"></p><p><img src="http://img.struy.cn/img/202304212302417.png"><br>川普 6</p><p><strong>lexica<code>[11]</code></strong></p><p>可以搜索 SD 生成的图片，也可以在线生成图片，看到合适的图片直接复制哈😄，会有对应的模型给出，在👆上面的模型下载网站下载即可</p><p><img src="http://img.struy.cn/img/202304212302055.png"></p><p><img src="http://img.struy.cn/img/202304212302191.png"></p><h1 id="常见问题及解决"><a href="#常见问题及解决" class="headerlink" title="常见问题及解决"></a>常见问题及解决</h1><p>在使用 Stable Diffusion 过程中可能会遇到各种常见问题，我们将在这里提供一些常见解决方案。</p><ul><li>1、M1 打开第一次任意模型生成图片，无法生成报错</li></ul><p><img src="http://img.struy.cn/img/202304212303332.png"></p><p>解决方案：按照提示操作即可</p><ul><li>2、无法调整图片高度，默认 512x512，改为 512x1024 报错：</li></ul><p><img src="http://img.struy.cn/img/202304212303145.png"></p><p>临时解决方案：改为 512x1023</p><ul><li>3、一些情况下某些功能需要在线下载插件、模块等，会出现证书错误</li></ul><p><img src="http://img.struy.cn/img/202304212303102.png"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 换成对应的Python版本</span><br><span class="line">/Applications/Python\ 3.8/Install\ Certificates.command</span><br></pre></td></tr></table></figure><ul><li>4、切换模型报错</li></ul><p><img src="http://img.struy.cn/img/202304212303717.png"></p><p>解决方案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动时增加 --no-half 选项即</span></span><br><span class="line">./web-ui.sh --no-half</span><br></pre></td></tr></table></figure><p>本文主要记录初步使用 SD 进行文生图的过程，至于图生图，ControlNet 等玩法后续分享</p><p>可以把你遇到的问题在评论区一起讨论</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwNzM4NjUzNw==&mid=2452411501&idx=1&sn=b6425f5340f1df1829a316da834f111a&chksm=8ca690abbbd119bdf049d732a5f52cc38884d09f92d1df65f625cc88184dcd3e2586a7d70e77#rd">原文链接</a></p><p>关注一下吧！<br><img src="http://img.struy.cn/img/202304212313285.png"></p><p>参考：</p><p>[1]. <a href="https://github.com/AbdBarho/stable-diffusion-webui-docker">https://github.com/AbdBarho/stable-diffusion-webui-docker</a></p><p>[2].<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Installation-on-Apple-Silicon">https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Installation-on-Apple-Silicon</a></p><p>[3].<a href="https://github.com/VinsonLaro/stable-diffusion-webui-chinese">https://github.com/VinsonLaro/stable-diffusion-webui-chinese</a></p><p>[4]. <a href="https://huggingface.co/AnonPerson/ChilloutMix/tree/main">https://huggingface.co/AnonPerson/ChilloutMix/tree/main</a> （内含一些亚洲 Lora）</p><p>[5]. <a href="https://aistudio.baidu.com/aistudio/datasetdetail/193534/0">https://aistudio.baidu.com/aistudio/datasetdetail/193534/0</a></p><p>[6]. <a href="https://aistudio.baidu.com/aistudio/datasetdetail/202078">https://aistudio.baidu.com/aistudio/datasetdetail/202078</a></p><p>[7]. <a href="https://huggingface.co/xiaolxl/GuoFeng3/tree/main">https://huggingface.co/xiaolxl/GuoFeng3/tree/main</a> (直接看文档)</p><p>[8]. <a href="https://aistudio.baidu.com/">https://aistudio.baidu.com/</a></p><p>[9]. <a href="https://huggingface.co/">https://huggingface.co/</a></p><p>[10]. <a href="https://civitai.com/">https://civitai.com/</a></p><p>[11]. <a href="https://lexica.art/">https://lexica.art/</a></p><p>文章参考：</p><p>AIGC 绘画理论与保姆级实战：</p><p><a href="https://zhuanlan.zhihu.com/p/617042733">https://zhuanlan.zhihu.com/p/617042733</a></p><p>SD 采样器：</p><p><a href="https://zhuanlan.zhihu.com/p/621083328">https://zhuanlan.zhihu.com/p/621083328</a></p><p>SD 如何安装使用不同模型：</p><p><a href="https://zhuanlan.zhihu.com/p/619553604">https://zhuanlan.zhihu.com/p/619553604</a></p><p>mac本地 SD 环境踩坑：</p><p><a href="https://zhuanlan.zhihu.com/p/608178376">https://zhuanlan.zhihu.com/p/608178376</a></p><p>SD使用入门与提示词技巧：</p><p><a href="https://zhuanlan.zhihu.com/p/577238010">https://zhuanlan.zhihu.com/p/577238010</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍我在本地搭建 Stable Diffusion Web UI 的体验过程，予以记录分享。&lt;/p&gt;</summary>
    
    
    
    <category term="AIGC" scheme="http://struy.cn/categories/AIGC/"/>
    
    
    <category term="AIGC" scheme="http://struy.cn/tags/AIGC/"/>
    
    <category term="Stable Diffusion" scheme="http://struy.cn/tags/Stable-Diffusion/"/>
    
    <category term="AI绘图" scheme="http://struy.cn/tags/AI%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>记Filebeat系统资源使用优化</title>
    <link href="http://struy.cn/2020/03/26/filebeat-cpu-and-mem-limit/"/>
    <id>http://struy.cn/2020/03/26/filebeat-cpu-and-mem-limit/</id>
    <published>2020-03-26T07:13:17.000Z</published>
    <updated>2023-04-25T00:32:10.346Z</updated>
    
    <content type="html"><![CDATA[<p>本文重点：<br>本文将着重关注filebeat，在filebeat在生产部署后，必定会对服务CPU、内存、网络有影响，如果将这些因素都在可控范围内，那是完全可以接受的。但是可能由于我们的配置不合理，或者非预期的情况导致CPU、内存占用过大，势必会影响到同在一起的业务应用稳定性。</p><span id="more"></span><blockquote><p>如今企业应用分布式、微服务盛行，针对分布于多节点的日志，会使用分布式日志系统架构，来满足业务开发查询多节点的日志并进行问题排查和定位。迄今为止，最为通用和成熟的就是elastic的ELK架构，我司现在也是按照如下通用架构(本文使用7.2版本的elastic套件)：</p><ul><li>filebeat(本文重点)：日志采集器，启动于业务服务器进行日志采集，并发送到kafka指定topic</li><li>kafka：大规模的企业应用通常会产生大量的日志，kafka可以为增长的日志削峰填谷</li><li>logstash:  将kafka的日志数据作为input，通过grok、oniguruma、mutate等过滤器将异构数据解析为结构化数据，最终存储到Elasticsearch</li><li>Elasticsearch：热门开源的搜索引擎，建立在 <a href="https://lucene.apache.org/core/">Apache Lucene</a> 之上，在当前场景用于存储结构化的日志数据</li><li>kibana：用于检索和管理ES数据的UI界面</li></ul></blockquote><p>我们将在本文一步步介绍我们在使用过程中遇到的问题，配置的优化，如何确保filebeat部署在业务主机上对业务的影响降到最低，如何使用cgroup来限制filebeat的系统资源使用配额！</p><h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>有些文章说filebeat的内存消耗很少，不会超过100M，这是没有针对场景和没有经过测试不严谨的说法(刚开始我们也没有完全覆盖所有情况进行测试，当然部分偶然情况有时无法预知)，当真正按照默认的简单配置将filebeat部署到生产环境，或者某个参数配置错误，都可能会出现意想不到的问题，轻则影响服务的整体性能，重则可能造成应用被OOM-killer导致业务中断。我们在刚开始使用filebeat时，觉得这个组件已经如此成熟，应该问题不大。所以使用了最简单最基本的配置将其部署，为后来的问题埋下了祸根！</p><p>我们在实际使用中的确遇到了如下问题:</p><ul><li>Filebeat内存爆增至数GB、导致业务服务器触发OOM-killer，将业务进程kill掉</li><li>平常不会很频繁，但一旦压测或者有大量异常时就会出现以上问题</li></ul><p>来看几个问题样本:</p><p><img src="https://img.struy.cn/img/202304231520154.png" alt="oom"></p><blockquote><p>这里是filebeat导致Linux OOM 的一个场景，可使用 <code>dmesg -T</code> 查看，这里可以看到，在OOM时，filebeat大概占用523561*4k ～&#x3D; 2G(rss是内存页数,乘上内存页大小4k就是实际物理内存)(多的时候有过5G，比如有的日志文件中打印了很多二进制内容)</p></blockquote><p><img src="https://img.struy.cn/img/202304231521757.png"></p><blockquote><p>使用业务问题样本日志进行的测试的结果</p></blockquote><h3 id="初版filebeat-yml配置"><a href="#初版filebeat-yml配置" class="headerlink" title="初版filebeat.yml配置"></a>初版filebeat.yml配置</h3><p>这是初版的配置文件，相对简单，基本没有做什么特殊的配置:</p><blockquote><p>这是一个错误的样本配置，请不要使用</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=========================== Filebeat inputs =============================</span></span><br><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span>                                <span class="comment"># 日志文件路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/data/logs/*/*.log</span></span><br><span class="line">  <span class="attr">exclude_files:</span> [<span class="string">.*file3.*|.*file4.*</span>]  <span class="comment"># 忽略的文件列表,正则匹配</span></span><br><span class="line">  <span class="attr">fields:</span>                               <span class="comment"># 在事件json中添加字段</span></span><br><span class="line">    <span class="attr">appName:</span> <span class="string">$&#123;serviceName&#125;</span></span><br><span class="line">    <span class="attr">agentHost:</span> <span class="string">$&#123;hostIp&#125;</span></span><br><span class="line">  <span class="attr">fields_under_root:</span> <span class="literal">true</span>               <span class="comment"># 将添加的字段加在JSON的最外层</span></span><br><span class="line">  <span class="attr">tail_files:</span> <span class="literal">false</span>                     <span class="comment"># 不建议一直开启,从日志文件的最后开始读取新内容</span></span><br><span class="line">  <span class="attr">multiline:</span>                            <span class="comment"># 多行匹配日志</span></span><br><span class="line">    <span class="attr">pattern:</span> <span class="string">&#x27;\[\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; \d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;&#x27;</span> <span class="comment"># 匹配一个以 [YYYY-MM-DD HH:mm:ss 开头的行</span></span><br><span class="line">    <span class="attr">negate:</span> <span class="literal">true</span>                        <span class="comment"># 将 pattern 取否(即不匹配pattern的情况)</span></span><br><span class="line">    <span class="attr">match:</span> <span class="string">after</span>                        <span class="comment"># 将其追加到上一行之后 pattern + negate + match 组合成一条语意为: 如果不匹配 [YYYY-MM-DD HH:mm:ss 开头的行，则将其合并到当前行的上一行</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">30s</span>                        </span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================== Processors ===============================</span></span><br><span class="line"><span class="comment"># ...此处省略</span></span><br><span class="line"><span class="comment">#=============================== output ===============================</span></span><br><span class="line"><span class="attr">output.kafka:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&#x27;ip1:9092&#x27;</span>,<span class="string">&#x27;ip2:9092&#x27;</span>]</span><br><span class="line">  <span class="attr">topic:</span> <span class="string">&#x27;my_topic&#x27;</span></span><br><span class="line">  <span class="attr">partition.round_robin:</span></span><br><span class="line">    <span class="attr">reachable_only:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">worker:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">required_acks:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">compression:</span> <span class="string">gzip</span></span><br><span class="line">  <span class="attr">max_message_bytes:</span> <span class="number">1000000</span>            <span class="comment"># 10MB</span></span><br><span class="line"><span class="comment">#================================ Logging ======================================</span></span><br><span class="line"><span class="comment"># ...此处省略</span></span><br></pre></td></tr></table></figure><h3 id="初期的问题和调整"><a href="#初期的问题和调整" class="headerlink" title="初期的问题和调整:"></a>初期的问题和调整:</h3><p>我们接收业务反馈CPU占据到了300%上下(四核)，并且偶现开头出现的OOM现象。</p><p>经过文档的查阅，发现几个明显的配置问题，并针对其做过一次初步的优化</p><ol><li><code>max_bytes</code>：单行日志的大小，默认为10M</li><li><code>queue.mem.events</code>：内存队列的大小默认为4096，有这个一个公式 <code>max_bytes * queue.mem.events</code>等于约占的内存量，这里默认<code>10M * 4096=40G</code>,再考虑到队列存储已经编码为json的数据，则原始数据应该也会存储在内存中，那满打满算就得有80G内存占用，即使不存储原始日志，日常的服务器也难以接受这40G的内</li><li><code>max_procs</code>:没有限制CPU内核数使用，在日志较频繁时可能导致CPU满载</li><li><code>ignore_older</code>:由于服务器上有历史日志，可以使用此选项忽略较旧的文件</li></ol><p>初步调整:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max_procs:</span> <span class="number">1</span>   <span class="comment"># *限制一个CPU核心,避免过多抢占业务资源</span></span><br><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">ignore_older:</span> <span class="string">48h</span> <span class="comment"># 忽略这个时间之前的文件(根据文件改变时间)</span></span><br><span class="line">  <span class="attr">max_bytes:</span> <span class="number">20480</span>  <span class="comment"># *单条日志的大小限制,将其从默认10M降低到20k，按照公式计算 20k * 4096 ～= 80M</span></span><br><span class="line"><span class="comment"># ... 省略其他配置</span></span><br></pre></td></tr></table></figure><h3 id="问题反复及之后的处理"><a href="#问题反复及之后的处理" class="headerlink" title="问题反复及之后的处理"></a>问题反复及之后的处理</h3><p>上面的改动，以为已经控制住问题，但是在不久之后还是反复出现了多次同样的OOM问题</p><p>filebeat限制单条消息最大不能超过20k，默认内存队列存储4096条记录，再加上明文日志，最高内存理论最高值在  20k * 4096 * 2 &#x3D; 160M 左右浮动，即使做了以上限制，还是不时出现内存爆增的情况</p><p>一时没有找到问题解决方案，我们做了如下的几个阶段策略:</p><p>阶段一：降低非预期情况下对应用的影响</p><p>阶段二：重新梳理和优化配置，达到优化内存的目的</p><h4 id="阶段一：降低非预期情况下对应用的影响"><a href="#阶段一：降低非预期情况下对应用的影响" class="headerlink" title="阶段一：降低非预期情况下对应用的影响"></a>阶段一：降低非预期情况下对应用的影响</h4><p>降低非预期情况下对应用的影响，是将filebeat进程的oom_score_adj值设置为999，在出现意外情况时OOM也优先 kill 掉filebeat，从而达到即使出现意外情况，也不会影响到业务进程</p><p>具体的操作是：</p><p><code>启动filebeat -&gt; 获取进程PID -&gt; 写入/proc/$pid/oom_score_adj 为999</code></p><blockquote><p>OOM killer 机制一般情况下都会kill掉占用内存最大的进程，在kill进程时，有个算分的过程，这个算分过程是一个综合的过程，包括当前进程的占用内存情况，系统打分，还有可由用户控制的oom_score_adj分值，将影响整体算分。</p><p>oom_score_adj的取值范围是 -1000 至 1000，值越大，OOM在kill时会优先kill掉此进程，为了最大限度让系统kill掉filebeat，我们必须将此值调整到最大</p></blockquote><h4 id="阶段二：重新梳理和优化配置，达到优化内存的目的"><a href="#阶段二：重新梳理和优化配置，达到优化内存的目的" class="headerlink" title="阶段二：重新梳理和优化配置，达到优化内存的目的"></a>阶段二：重新梳理和优化配置，达到优化内存的目的</h4><p>针对多次问题的场景，进行样本的提取，发现多次问题出现的都是在大量的堆栈异常日志中出现，怀疑是多行合逻辑不对导致的问题：</p><p>下面我们来着重看一下多行最初配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">multiline:</span>                            <span class="comment"># 多行匹配日志</span></span><br><span class="line">   <span class="attr">pattern:</span> <span class="string">&#x27;\[\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; \d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;&#x27;</span> <span class="comment"># 匹配一个以 [YYYY-MM-DD HH:mm:ss 开头的行</span></span><br><span class="line">   <span class="attr">negate:</span> <span class="literal">true</span>                        <span class="comment"># 将 pattern 取否(即不匹配pattern的情况)</span></span><br><span class="line">   <span class="attr">match:</span> <span class="string">after</span>                        <span class="comment"># 将其追加到上一行之后 pattern + negate + match 组合成一条语意为: 如果不匹配 [YYYY-MM-DD HH:mm:ss 开头的行，则将其合并到当前行的上一行</span></span><br><span class="line">   <span class="attr">timeout:</span> <span class="string">30s</span>                        </span><br></pre></td></tr></table></figure><p>发现官网对于此参数的默认值是5s，但是现在却被误配置成了30s，肯定是有问题的啦</p><p><img src="https://img.struy.cn/img/202304231522881.png"></p><p>问题的原因应该就在 <code>multiline.timeout</code>这个参数之上，我们尝试调整多次参数的大小进行测试:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于样本不同，可能内存量也会有所不同，这里选取的是在业务服务中有大量错误堆栈的日志进行测试</span></span><br><span class="line"><span class="comment"># 在其他参数不变的情况下测试</span></span><br><span class="line"><span class="attr">multiline.timeout:</span> <span class="string">30s</span> <span class="string">-&gt;</span>  <span class="string">10s</span>  <span class="string">-&gt;</span>   <span class="string">3s</span>  <span class="string">-&gt;</span>  <span class="string">2s</span>   <span class="string">-&gt;</span>   <span class="string">1s</span></span><br><span class="line">                   <span class="number">5.</span><span class="string">3G</span> <span class="string">-&gt;</span> <span class="number">4.</span><span class="string">8G</span> <span class="string">-&gt;</span> <span class="string">~2.5G</span> <span class="string">-&gt;</span> <span class="string">~730M</span>  <span class="string">-&gt;</span> <span class="string">~540M</span></span><br></pre></td></tr></table></figure><p>我的对官方的这句话的理解是:</p><blockquote><p>超时时间后,即使还未匹配到下一个多行事件，也将此次匹配的事件刷出</p></blockquote><p>如果日志中如果包含很多错误堆栈，或者不规范的日志大量匹配多行逻辑，会产生过多的多行合并任务，但是超时时间过长，过多的任务就会最大限度的匹配和在内存中等待，占用更多的内存！</p><p>除此以外我们也做了其他调整包括但不限于如下:</p><p><code>queue.mem.events</code>:从默认的4096 设置到了2048</p><p><code>queue.mem.flush.min_events</code>: 从默认2048设置到了1536</p><p><code>multiline.max_lines</code>:从默认500行设置到了200行</p><p>最后我们的最优配置如下，在调整之后将问题样本进行测试，内存只占用350M～500M之间：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=========================== Filebeat inputs =============================</span></span><br><span class="line"><span class="attr">max_procs:</span> <span class="number">1</span>                            <span class="comment"># *限制一个CPU核心,避免过多抢占业务资源</span></span><br><span class="line"><span class="attr">queue.mem.events:</span> <span class="number">2048</span>                  <span class="comment"># 存储于内存队列的事件数，排队发送 (默认4096)</span></span><br><span class="line"><span class="attr">queue.mem.flush.min_events:</span> <span class="number">1536</span>        <span class="comment"># 小于 queue.mem.events ,增加此值可提高吞吐量 (默认值2048)</span></span><br><span class="line"><span class="comment">#queue.mem.flush.timeout: 1s             # 这是一个默认值，到达 min_events 需等待多久刷出</span></span><br><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ignore_older:</span> <span class="string">48h</span>                     <span class="comment"># 忽略这个时间之前的文件(根据文件改变时间)</span></span><br><span class="line">  <span class="attr">max_bytes:</span> <span class="number">20480</span>                      <span class="comment"># *单条日志的大小限制,建议限制(默认为10M,queue.mem.events * max_bytes 将是占有内存的一部分)</span></span><br><span class="line">  <span class="attr">recursive_glob.enabled:</span> <span class="literal">true</span>          <span class="comment"># 是否启用glob匹配,可匹配多级路径(最大8级)：/A/**/*.log =&gt; /A/*.log ~ /A/**/**/**/**/**/**/**/**/*.log  </span></span><br><span class="line">  <span class="attr">paths:</span>                                <span class="comment"># 日志文件路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/data/logs/**/*.log</span></span><br><span class="line">  <span class="attr">exclude_files:</span> [<span class="string">.*file1.*|stdout.log|.*file2.*</span>] <span class="comment"># 忽略的文件列表,正则匹配</span></span><br><span class="line">  <span class="attr">fields:</span>                               <span class="comment"># 在事件json中添加字段</span></span><br><span class="line">    <span class="attr">appName:</span> <span class="string">$&#123;serviceName&#125;</span></span><br><span class="line">    <span class="attr">agentHost:</span> <span class="string">$&#123;hostIp&#125;</span></span><br><span class="line">  <span class="attr">fields_under_root:</span> <span class="literal">true</span>               <span class="comment"># 将添加的字段加在JSON的最外层</span></span><br><span class="line">  <span class="attr">tail_files:</span> <span class="literal">false</span>                     <span class="comment"># 不建议一直开启,从日志文件的最后开始读取新内容(保证读取最新文件),但是如果有日志轮转，可能导致文件内容丢失，建议结合 ignore_older 将其设置为false</span></span><br><span class="line">  <span class="attr">multiline:</span>                            <span class="comment"># 多行匹配日志 (https://www.elastic.co/guide/en/beats/filebeat/7.2/multiline-examples.html)</span></span><br><span class="line">    <span class="attr">pattern:</span> <span class="string">&#x27;\[\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; \d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;&#x27;</span> <span class="comment"># 匹配一个以 [YYYY-MM-DD HH:mm:ss 开头的行</span></span><br><span class="line">    <span class="attr">negate:</span> <span class="literal">true</span>                        <span class="comment"># 将 pattern 取否(即不匹配pattern的情况)</span></span><br><span class="line">    <span class="attr">match:</span> <span class="string">after</span>                        <span class="comment"># 将其追加到上一行之后 pattern + negate + match 组合成一条语意为: 如果不匹配 [YYYY-MM-DD HH:mm:ss 开头的行，则将其合并到当前行的上一行</span></span><br><span class="line">    <span class="attr">max_lines:</span> <span class="number">200</span>                      <span class="comment"># 最多匹配多少行，如果超出最大行数，则丢弃多余的行(默认500)</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">1s</span>                         <span class="comment"># 超时时间后,即使还未匹配到下一个行日志(下一个多行事件)，也将此次匹配的事件刷出 (默认5s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================== Processors ===============================</span></span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line"><span class="comment">#=============================== output ===============================</span></span><br><span class="line"><span class="attr">output.kafka:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&#x27;ip1:9092&#x27;</span>,<span class="string">&#x27;ip2:9092&#x27;</span>]</span><br><span class="line">  <span class="attr">topic:</span> <span class="string">&#x27;my_topic&#x27;</span></span><br><span class="line">  <span class="attr">partition.round_robin:</span></span><br><span class="line">    <span class="attr">reachable_only:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">worker:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">required_acks:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">compression:</span> <span class="string">gzip</span></span><br><span class="line">  <span class="attr">max_message_bytes:</span> <span class="number">1000000</span>            <span class="comment"># 10MB</span></span><br><span class="line"><span class="comment">#================================ Logging ======================================</span></span><br><span class="line"><span class="comment"># 省略</span></span><br></pre></td></tr></table></figure><h3 id="使用cgroup限制资源用量"><a href="#使用cgroup限制资源用量" class="headerlink" title="使用cgroup限制资源用量"></a>使用cgroup限制资源用量</h3><p>对于我们的业务机器来说，让filebeat独占一个CPU去进行日志收集，显然不被业务人员所接受，因为在业务高峰期日志量会很大，filebaat进行大吞吐量的日志收集、多行合并、消息发送；很有可能会限制业务的性能，可能没有filebeat我原本需要10台主机，但是有了filebeat我就需要15台主机来承载高峰业务。</p><p>上面的配置虽然已经基本控制住内存用量，但也有可能出现不同的不可预期的情况导致内存增长</p><p>我们该如何限制CPU使用量和应对意想不到的内存增长情况？</p><p>答案是：绝对性的控制CPU&#x2F;内存在一个范围内，我们可以使用cgroup来实现</p><p>什么是cgroup？</p><blockquote><p>cgroups 是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，可以对 cpu，内存等资源实现精细化的控制，容器 Docker 技术就使用了 cgroups 提供的资源限制能力来完成cpu，内存等部分的资源控制。</p><p>另外，开发者也可以使用cgroup提供的精细化的控制能力，来限制某一组&#x2F;一个进程的资源使用，比如我们的日志agent需要部署到应用服务器，为了保证系统稳定性，可以限制agent的资源用量在合理范围。</p><p>由于篇幅限制，这里对cgroup就不多做介绍了，只说如何使用起来，如果有不明白的，可以查看下方参考链接</p></blockquote><h4 id="如何使用cgroup"><a href="#如何使用cgroup" class="headerlink" title="如何使用cgroup"></a>如何使用cgroup</h4><p>cgroup相关的所有操作都是基于内核中的cgroup virtual filesystem，使用cgroup很简单，挂载这个文件系统即可。一般情况默认已经挂载到<code>/sys/fs/cgroup</code>目录下了</p><p><code>mount | grep cgroup</code> 查看系统默认是否挂载cgroup，cgroup包含很多子系统，用来控制进程不同的资源使用，我们只用其中cpu和memory这两个</p><p><img src="https://img.struy.cn/img/202304231523898.png"></p><h4 id="用到的cgroup的子系统："><a href="#用到的cgroup的子系统：" class="headerlink" title="用到的cgroup的子系统："></a>用到的cgroup的子系统：</h4><ol><li>cpu 子系统，主要限制进程的 cpu 使用率</li><li>memory 子系统，可以限制进程的 memory 使用量</li></ol><h4 id="创建子cgroup"><a href="#创建子cgroup" class="headerlink" title="创建子cgroup"></a>创建子cgroup</h4><ul><li>如果需要限制cpu，则在已挂载的 <code>/sys/fs/cgroup/cpu</code> 子系统下建立任意目录，如<code>filebeat_cpu</code></li><li>如果需要限制内存，则在已挂载的 <code>/sys/fs/cgroup/memory</code> 子系统下建立任意目录，如<code>filebeat_memory</code></li></ul><p>filebeat_cpu和filebeat_memory下都会自动生成与上级目录相同的文件，我们重点关注一下几个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">filebeat_cpu</span><br><span class="line">- cgroup.procs      <span class="comment"># 限制的进程pid</span></span><br><span class="line">- cpu.cfs_period_us   <span class="comment"># 用来配置时间周期长度(us)</span></span><br><span class="line">- cpu.cfs_quota_us    <span class="comment"># 用来配置当前cgroup在设置的周期长度内所能使用的CPU时间数(us)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cpu.cfs_period_us&amp;cpu.cfs_quota_us 两个文件配合起来设置CPU的使用上限</span></span><br><span class="line"><span class="comment"># cfs_period_us的取值范围为1毫秒（ms）到1秒（s），cfs_quota_us的取值大于1ms即可</span></span><br><span class="line"><span class="comment"># 如果cfs_quota_us的值为-1（默认值），表示不受cpu时间的限制</span></span><br><span class="line"><span class="comment"># 如限制使用1个CPU的25%（每40ms能使用10ms的CPU时间，即使用一个CPU核心的25%)</span></span><br><span class="line"><span class="comment"># 则echo 40000 &gt; cpu.cfs_period_us &amp;&amp; echo 40000 &gt; cpu.cfs_quota_us</span></span><br><span class="line"></span><br><span class="line">filebeat_memory</span><br><span class="line">- cgroup.procs  <span class="comment"># 限制的进程pid</span></span><br><span class="line">- memory.limit_in_bytes   <span class="comment"># 限制的内存大小</span></span><br><span class="line">- memory.oom_control     </span><br><span class="line"></span><br><span class="line"><span class="comment"># memory.oom_control</span></span><br><span class="line"><span class="comment"># 0:将启动OOM-killer，当内核无法给进程分配足够的内存时，将会直接kill掉该进程</span></span><br><span class="line"><span class="comment"># 1:表示不启动OOM-killer，当内核无法给进程分配足够的内存时，将会暂停该进程直到有空余的内存之后再继续运行；</span></span><br><span class="line"><span class="comment"># 同时，memory.oom_control还包含一个只读的under_oom字段，用来表示当前是否已经进入oom状态，也即是否有进程被暂停了。</span></span><br></pre></td></tr></table></figure><p>改造我们的filebeat启动脚本,支持在启动后限制内存和cpu:</p><blockquote><p>restartFilebeat.sh</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># @metainfo: filebeat 启动脚本</span></span><br><span class="line"><span class="comment"># @author: struy</span></span><br><span class="line"><span class="comment"># 1.设置filebeat需要的主机和应用信息，详情见filebeat.yml</span></span><br><span class="line"><span class="comment"># 2.设置针对filebeat CPU、内存的 cgroup 限额: CPU -&gt; 单核25%，内存 -&gt; 500M </span></span><br><span class="line"><span class="comment"># 3.停止旧进程，检查环境变量，重启filebeat</span></span><br><span class="line"><span class="comment"># 4.写入filebeat进程oom_score_adj值(999),写入进程号至为filebeat准备的cgroup.procs中</span></span><br><span class="line"><span class="comment"># 5.review 配置信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================variable============================= #</span></span><br><span class="line">_hostIp=`ifconfig eth0|grep <span class="string">&quot;inet &quot;</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line">_serviceName=(`ps -ef |grep -Ev <span class="string">&#x27;grep&#x27;</span> | grep -Eo <span class="string">&#x27;applicationName=.*? &#x27;</span> | awk <span class="string">&#x27;&#123;print  $1&#125;&#x27;</span> | awk -F = <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`)</span><br><span class="line"></span><br><span class="line">filebeat_oom_score_adj=999  <span class="comment"># OOM时,将优先OOM掉filebeat,虽然现在占用不大，为避免特殊情况影响业务</span></span><br><span class="line">filebeat_memory_limit_mb=500M     <span class="comment"># 内存限额</span></span><br><span class="line">filebeat_single_cpu_scale=0.25 <span class="comment"># 占单个cpu的比例</span></span><br><span class="line">filebeat_cfs_period_us=40000<span class="comment"># CPU的时间周期</span></span><br><span class="line">filebeat_cfs_quota_us=`<span class="built_in">echo</span> <span class="variable">$filebeat_single_cpu_scale</span> <span class="variable">$filebeat_cfs_period_us</span> | awk <span class="string">&#x27;&#123;printf &quot;%0.0f\n&quot; ,$1*$2&#125;&#x27;</span>`  <span class="comment"># 周期内的限额 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================== ENV ============================= #</span></span><br><span class="line"><span class="built_in">export</span> hostIp=<span class="variable">$_hostIp</span></span><br><span class="line"><span class="built_in">export</span> serviceName=<span class="variable">$_serviceName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================== cgroup check and setting ============================= #</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="string">&quot;/sys/fs/cgroup/cpu/filebeat_cpu&quot;</span> ]] &amp;&amp; [[ -d <span class="string">&quot;/sys/fs/cgroup/memory/filebeat_memory&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;cgroup [filebeat_cpu、filebeat_memory] is exist&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;cgroup [filebeat_cpu、filebeat_memory] is not exist , now mkdir and setting quota&#x27;</span></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line"><span class="built_in">mkdir</span> /sys/fs/cgroup/cpu/filebeat_cpu</span><br><span class="line"><span class="comment"># 内存</span></span><br><span class="line"><span class="built_in">mkdir</span> /sys/fs/cgroup/memory/filebeat_memory</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cfs_period_us用来配置时间周期长度</span></span><br><span class="line"><span class="comment"># cfs_quota_us用来配置当前cgroup在设置的周期长度内所能使用的CPU时间数</span></span><br><span class="line"><span class="comment"># 两个文件配合起来设置CPU的使用上限。两个文件的单位都是微秒（us），</span></span><br><span class="line"><span class="comment"># cfs_period_us的取值范围为1毫秒（ms）到1秒（s），cfs_quota_us的取值大于1ms即可</span></span><br><span class="line"><span class="comment"># 如果cfs_quota_us的值为-1（默认值），表示不受cpu时间的限制</span></span><br><span class="line"><span class="comment"># 限制使用1个CPU的25%（每40ms能使用10ms的CPU时间，即使用一个CPU核心的25%）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$filebeat_cfs_period_us</span> &gt; /sys/fs/cgroup/cpu/filebeat_cpu/cpu.cfs_period_us</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$filebeat_cfs_quota_us</span> &gt; /sys/fs/cgroup/cpu/filebeat_cpu/cpu.cfs_quota_us</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存限制小于 400M,写入自动转换为bytes</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$filebeat_memory_limit_mb</span> &gt; /sys/fs/cgroup/memory/filebeat_memory/memory.limit_in_bytes</span><br><span class="line"><span class="comment"># 0:即使系统有交换空间，也不使用交换空间</span></span><br><span class="line"><span class="comment">#echo 0 &gt; /sys/fs/cgroup/memory/filebeat_memory/memory.swappiness</span></span><br><span class="line"><span class="comment"># 0:OOM-killer 1:暂停进程等有可用内存再继续运行</span></span><br><span class="line"><span class="comment">#echo 0 &gt; /sys/fs/cgroup/memory/filebeat_memory/memory.oom_control</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================kill old============================= #</span></span><br><span class="line">oldPid=(`ps -ef|grep <span class="string">&#x27;agent7.2/filebeat-7.2.0-linux-x86_64/filebeat&#x27;</span> |grep -v <span class="string">&#x27;grep&#x27;</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`)</span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="variable">$oldPid</span> ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;filebeat agent not runing,now run!&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;oldPid =&gt; [<span class="variable">$&#123;oldPid[*]&#125;</span>],kill now&quot;</span></span><br><span class="line"><span class="built_in">kill</span> <span class="variable">$&#123;oldPid[*]&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span> 1s</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================== check ENV and run ============================= #</span></span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="variable">$hostIp</span> ]]||[[ ! <span class="variable">$serviceName</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;env [hostIp] or [serviceName] is not set, cancel start!&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$&#123;#serviceName[*]&#125;</span> -ne 1 ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;env [serviceName] more than one:serviceName =&gt; [<span class="variable">$&#123;serviceName[*]&#125;</span>],cancel start!&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">nohup</span> /data/agent7.2/filebeat-7.2.0-linux-x86_64/filebeat run -e -c /data/agent7.2/filebeat-7.2.0-linux-x86_64/filebeat.yml  &gt;&gt; /data/agent7.2/nohup.out 2&gt;&amp;1 &amp;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !!! 确保已经在运行,延时可能在cgroup未生效的情况下应用内存就增长了，但是不会超过限制内存的20%</span></span><br><span class="line"><span class="built_in">sleep</span> 1s</span><br><span class="line"></span><br><span class="line">pid=(`ps -ef|grep <span class="string">&#x27;agent7.2/filebeat-7.2.0-linux-x86_64/filebeat&#x27;</span> |grep -v <span class="string">&#x27;grep&#x27;</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="variable">$pid</span> ]];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;filebeat not runing,cgroup no check&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment"># ========================== setting oom_socre_adj ============================= #</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$filebeat_oom_score_adj</span> &gt; /proc/<span class="variable">$pid</span>/oom_score_adj</span><br><span class="line"><span class="comment"># ========================== setting filebeat cgroup procs ============================= #</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pid</span> &gt; /sys/fs/cgroup/cpu/filebeat_cpu/cgroup.procs</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pid</span> &gt; /sys/fs/cgroup/memory/filebeat_memory/cgroup.procs</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================== review setting ============================= #</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;pid-&gt;<span class="variable">$pid</span> hostName-&gt;<span class="variable">$HOSTNAME</span> hostIp-&gt;<span class="variable">$hostIp</span> appName-&gt;<span class="variable">$serviceName</span>&quot;</span> \</span><br><span class="line"><span class="string">&quot;filebeat_oom_score_adj-&gt;&quot;</span>`<span class="built_in">cat</span> /proc/<span class="variable">$pid</span>/oom_score` \</span><br><span class="line"><span class="string">&quot;filebeat_cpu/cpu.cfs_period_us-&gt;&quot;</span>`<span class="built_in">cat</span> /sys/fs/cgroup/cpu/filebeat_cpu/cpu.cfs_period_us` \</span><br><span class="line"><span class="string">&quot;filebeat_cpu/cpu.cfs_quota_us-&gt;&quot;</span>`<span class="built_in">cat</span> /sys/fs/cgroup/cpu/filebeat_cpu/cpu.cfs_quota_us` \</span><br><span class="line"><span class="string">&quot;filebeat_memory/memory.limit_in_bytes-&gt;&quot;</span>`<span class="built_in">cat</span> /sys/fs/cgroup/memory/filebeat_memory/memory.limit_in_bytes`</span><br></pre></td></tr></table></figure><p>限制:</p><p>CPU -&gt; 单核25%</p><p>内存 -&gt; 500M,大于此值则触发cgroup的OOM-killer机制</p><h4 id="优化前优化后的对比"><a href="#优化前优化后的对比" class="headerlink" title="优化前优化后的对比"></a>优化前优化后的对比</h4><p>优化前：</p><p><img src="https://img.struy.cn/img/202304231524441.png"></p><p>优化后:</p><p><img src="https://img.struy.cn/img/202304231524254.png"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.elastic.co/guide/en/beats/filebeat/7.2/configuring-howto-filebeat.html">Filebeat 官网配置文档</a></li><li><a href="http://www.wowotech.net/memory_management/oom.html">OOM相关参数</a></li><li><a href="https://segmentfault.com/a/1190000006917884">Linux cgroup 概述</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文重点：&lt;br&gt;本文将着重关注filebeat，在filebeat在生产部署后，必定会对服务CPU、内存、网络有影响，如果将这些因素都在可控范围内，那是完全可以接受的。但是可能由于我们的配置不合理，或者非预期的情况导致CPU、内存占用过大，势必会影响到同在一起的业务应用稳定性。&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="http://struy.cn/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Filebeat" scheme="http://struy.cn/tags/Filebeat/"/>
    
    <category term="ELK" scheme="http://struy.cn/tags/ELK/"/>
    
    <category term="cgroup" scheme="http://struy.cn/tags/cgroup/"/>
    
    <category term="Linux" scheme="http://struy.cn/tags/Linux/"/>
    
    <category term="可观测性" scheme="http://struy.cn/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>构建与部署中心基本设计</title>
    <link href="http://struy.cn/2019/01/03/build-deploy-server-1/"/>
    <id>http://struy.cn/2019/01/03/build-deploy-server-1/</id>
    <published>2019-01-03T12:09:36.000Z</published>
    <updated>2023-04-27T10:17:29.762Z</updated>
    
    <content type="html"><![CDATA[<p>构建与部署，是日常开发过程中很频繁也很关键的步骤，本文将介绍dapeng部署构建中心两大模块的核心概念和操作流程。</p><span id="more"></span><h2 id="平台架构"><a href="#平台架构" class="headerlink" title="平台架构"></a>平台架构</h2><p>系统分为两个主要部分:</p><ul><li><p>配置中心<br>配置将服务运行所需要的所有配置项入库, 负责生成运行所需的配置文件(一般为yml), 并指示agent进行系统的发布&#x2F;回滚等.</p></li><li><p>agent-client(以下简称agent).<br>agent部署在服务节点上, 并接收配置中心的指令并根据指令做具体的操作.<br><img src="http://img.struy.cn/19-1-3/61850243.jpg"></p></li><li><p>配置管理员在web配置中心进行增删改操作，更新配置</p></li><li><p>配置管理员确认配置参数无误，进行配置的同步下发(web端表现为升级操作)</p><ul><li>配置中心从数据库获取各项配置返回至配置中心</li><li>配置中心将配置按照优先级进行整理，基于docker-compose文件模型生成最终配置</li><li>在升级前通过指定事件消息将当前已经在运行的配置文件内容返回，与配置中心生成的配置文件进行对比(差异可视)</li><li>当文件最终确定后，通过事件消息将配置发送至agent</li><li>agent接收到事件消息后将文件生成，并执行指定的操作(升级)</li></ul></li><li><p>升级完成</p></li></ul><h2 id="主要功能项"><a href="#主要功能项" class="headerlink" title="主要功能项"></a>主要功能项</h2><ul><li>持续集成<ul><li>构建任务<ul><li>展示构建任务列表</li><li>发送构建操作</li><li>查看构建历史</li><li>删除构建历史</li><li>查看当前构建任务</li><li>点击历史查看构建日志</li></ul></li></ul></li><li>发布部署<ul><li>服务管理<ul><li>展示服务列表</li><li>导入导出服务</li><li>服务信息增删改查</li></ul></li><li>环境管理<ul><li>展示环境集列表 </li><li>环境集信息增删改查</li><li>指定构建主机</li><li>管理SetSubEnv</li></ul></li><li>节点管理<ul><li>展示节点列表</li><li>节点信息增删改查</li></ul></li><li>部署单元管理<ul><li>展示部署单元列表</li><li>部署单元增删改查</li><li>批量修改tag</li><li>批量修改分支</li><li>对比配置</li></ul></li><li>上线部署<ul><li>展示容器信息;容器状态，容器tag</li><li>升级,停止,重启,预览配置,移除容器操作</li><li>查看agent列表</li></ul></li><li>部署记录<ul><li>展示部署的操作记录</li><li>回滚服务配置</li></ul></li><li>文件管理<ul><li>管理容器与宿主机卷挂载的文件，一般是内容有限内容的明文配置文件</li><li>文件增删改查</li><li>关联部署单元，换言之可具体关联某个节点的容器</li></ul></li><li>网络管理<ul><li>预定义和配置容器网络参数</li><li>将配置的网络关联到节点</li><li>下发网络配置，在关联节点创建网络</li></ul></li></ul></li></ul><h2 id="功能主逻辑"><a href="#功能主逻辑" class="headerlink" title="功能主逻辑"></a>功能主逻辑</h2><p><img src="http://img.struy.cn/19-1-3/52076907.jpg"></p><p><strong>服务</strong>：微服务架构，将业务细化，每个模块作为一个服务向外提供服务，往往每个模块具体化为一个代码库，而这里的服务就是描述这个镜像最基本的配置</p><p><strong>环境集</strong>：一个环境集合，例如测试环境中的某个sandbox环境，生产的统一集群环境。环境集中包含一个环境集中服务高度共享的<code>environment</code>信息</p><p><strong>SetSubEnv</strong>：环境集内描述某个服务在某个节点的<code>environment</code>信息</p><p><strong>节点</strong>：节点从属于环境，一个环境集下可存在多个节点。如生产环境的多个节点app1，app2</p><p><strong>部署单元</strong>：部署单元由环境集，节点，服务，三部分组合而成的服务容器(通俗的描述：就是在某个环境集的某台节点部署某个服务，在docker服务下表现为服务容器，运行状态下可使用docker ps查询)</p><p><strong>文件</strong>：文件将会绑定部署单元，而部署单元在升级时会携带绑定的文件和内容<br><strong>网络</strong>：解决特定的网络环境问题，如mtu,容器子网网段</p><p><strong>yaml配置文件</strong>：每一个容器，在docker-compose模型中，都可以以一份yaml文件来描述其运行信息，应用以各项配置的优先级<code>(服务&lt;环境集&lt;SetSubEnv&lt;节点&lt;部署单元)</code>进行整合，最终生成为一份yaml配置文件。</p><p><strong>构建任务</strong>：构建任务描述信心实际上是部署单元的描述信息(在某个环境构建某个服务的某个分支，部署在这个环境的某个节点上)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;构建与部署，是日常开发过程中很频繁也很关键的步骤，本文将介绍dapeng部署构建中心两大模块的核心概念和操作流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Dapeng微服务" scheme="http://struy.cn/tags/Dapeng%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="CICD" scheme="http://struy.cn/tags/CICD/"/>
    
    <category term="DevOps" scheme="http://struy.cn/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>构建与部署中心使用流程</title>
    <link href="http://struy.cn/2019/01/03/build-deploy-server-use2/"/>
    <id>http://struy.cn/2019/01/03/build-deploy-server-use2/</id>
    <published>2019-01-03T12:09:36.000Z</published>
    <updated>2023-04-25T00:32:10.346Z</updated>
    
    <content type="html"><![CDATA[<p>配置部署中心，包含三大模块：<br>1.配置管理：管理线上服务的参数配置(如：超时，路由，限流，负载均衡，以及服务白名单的管理)<br>2.持续集成：完成服务代码打包，服务镜像的构建过程<br>3.发布部署：完成线上服务的环境变量变更，服务挂载文件内容变更，线上服务的发布更新&#x2F;启动停止，更有发布记录以供查询。</p><span id="more"></span><p>此篇文档着重说明其中第三个模块发布部署的大体流程：<br>使用菜单：</p><p><img src="http://img.struy.cn/19-1-4/75541017.jpg"></p><p>发布部署包含六个子菜单，每个菜单的功能如下：<br>文件管理：管理所有服务容器的配置文件，如:服务网关需要挂载于宿主机的服务白名单文件，可以通过此功能进行配置文件内容，关联某台机器的服务容器进行挂载。<br>服务管理：管理服务基础信息<br>环境管理：管理环境集信息，以及环境集下某个服务的环境变量信息<br>节点管理：管理节点信息（一个节点总是从属于某一个环境集）<br>部署单元：管理部署的服务信息，确定服务最终部署的节点和使用的镜像版本(简而言之就是具体到某个服务容器)<br>上线部署：上线部署数据来自于部署单元进行筛选展示，执行具体的上线升级，重启，停止操作，可以预览服务运行状态和运行的基本信息(如：当前运行的镜像tag号，服务的最后更新时间，是否需要更新等信息)<br>部署记录：记录每一次部署升级操作(包括重启和停止)，可预览本次升级的yml配置文件并做出有效diff对比</p><h2 id="一次完整的上线操作："><a href="#一次完整的上线操作：" class="headerlink" title="一次完整的上线操作："></a>一次完整的上线操作：</h2><p><strong>上线场景</strong>：上线一个新服务至生产某节点，完成发布，验证存在发布记录。<br>已知服务基础信息：存在数据库连接，存在生产环境必须的环境变量配置，存在文件需要挂载至宿主机，需要将服务端口映射至宿主机</p><h3 id="添加新服务："><a href="#添加新服务：" class="headerlink" title="添加新服务："></a>添加新服务：</h3><p>服务管理&#x3D;&gt;新增（可根据现有服务进行复制）<br><img src="http://img.struy.cn/19-1-4/91339380.jpg"><br>以上添加了一个基础服务，配置了服务信息，服务镜像字段不需要填写tag号，只需填写基础镜像即可。</p><blockquote><p>服务中添加环境变量(ENV)的原则是：服务中不易变动的环境变量</p></blockquote><h3 id="为需要发布的新服务的环境添加公共环境变量配置："><a href="#为需要发布的新服务的环境添加公共环境变量配置：" class="headerlink" title="为需要发布的新服务的环境添加公共环境变量配置："></a>为需要发布的新服务的环境添加公共环境变量配置：</h3><p><img src="http://img.struy.cn/19-1-4/32632852.jpg"></p><blockquote><p>环境集中添加环境变量(ENV)原则为：公共的环境变量，数据库资源配置信息</p></blockquote><p>如果新服务有额外的环境变量需要添加，且环境变量只用于新加服务，对于其他服务完全不会需要这些环境变量，则需要添加SetSubEnv，如下：</p><p><img src="http://img.struy.cn/19-1-4/76343258.jpg"></p><h3 id="添加一个新节点用于部署新服务："><a href="#添加一个新节点用于部署新服务：" class="headerlink" title="添加一个新节点用于部署新服务："></a>添加一个新节点用于部署新服务：</h3><p>节点管理&#x3D;&gt;新增<br><img src="http://img.struy.cn/19-1-4/83933177.jpg"><br>节点从属某个环境集，所以在添加节点时需要选定所属环境集：<br>是否是外部机器用于区分是否需要部署服务，一般为否<br>节点上的环境变量(ENV)添加原则为：尽量不添加，如果添加，必将与节点关联密切，或因节点而异的环境变量。</p><h3 id="添加一个部署单元："><a href="#添加一个部署单元：" class="headerlink" title="添加一个部署单元："></a>添加一个部署单元：</h3><p>部署单元&#x3D;&gt;新增<br><img src="http://img.struy.cn/19-1-4/1357418.jpg"><br>一个部署单元确认了一个节点上的一个服务容器。<br>部署单元环境变量添加原则：只要没有特殊情况不需要添加，一旦添加，只会在当前部署单元所在节点生效。</p><h3 id="添加服务外部文件挂载："><a href="#添加服务外部文件挂载：" class="headerlink" title="添加服务外部文件挂载："></a>添加服务外部文件挂载：</h3><p>文件描述了一个或多个容器的VOLUMES信息,当添加一个文件后，都需要与指定的部署单元(容器)进行关联,关联的文件或文件夹最终将作为容器的VOLUMES,点击关联部署单元按钮查看或关联&#x2F;取消关联部署单元。<br><img src="http://img.struy.cn/19-1-4/39969678.jpg"></p><h3 id="上线升级："><a href="#上线升级：" class="headerlink" title="上线升级："></a>上线升级：</h3><p>至此，所有新加的服务配置都已经完成，以上配置在升级时最终都会综合为一份配置文件进行下发如下：<br><img src="http://img.struy.cn/19-1-4/56454488.jpg"></p><h3 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h3><p><img src="http://img.struy.cn/19-1-4/21817040.jpg"><br>从上面操作可以看到，之前添加的环境变量，文件，都生效于配置文件，确认无误后升级即可启动对应节点上的服务。</p><h3 id="部署记录-x2F-回滚"><a href="#部署记录-x2F-回滚" class="headerlink" title="部署记录&#x2F;回滚"></a>部署记录&#x2F;回滚</h3><p><img src="http://img.struy.cn/19-1-4/35837507.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置部署中心，包含三大模块：&lt;br&gt;1.配置管理：管理线上服务的参数配置(如：超时，路由，限流，负载均衡，以及服务白名单的管理)&lt;br&gt;2.持续集成：完成服务代码打包，服务镜像的构建过程&lt;br&gt;3.发布部署：完成线上服务的环境变量变更，服务挂载文件内容变更，线上服务的发布更新&amp;#x2F;启动停止，更有发布记录以供查询。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Dapeng微服务" scheme="http://struy.cn/tags/Dapeng%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="CICD" scheme="http://struy.cn/tags/CICD/"/>
    
    <category term="DevOps" scheme="http://struy.cn/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>dapeng构建中心随记</title>
    <link href="http://struy.cn/2018/12/10/dapeng-build-center-essay/"/>
    <id>http://struy.cn/2018/12/10/dapeng-build-center-essay/</id>
    <published>2018-12-10T13:57:55.000Z</published>
    <updated>2023-04-25T00:32:10.346Z</updated>
    
    <content type="html"><![CDATA[<p>回顾原有的几个概念：<br>服务：微服务架构，每个项目代码库，都最终打包为一个docker镜像，而这里的服务就是描述这个镜像最基本的配置，描述一个应用最初，最抽象的状态<br>环境集：一个环境集合，例如测试环境中的某个sandbox环境，生产的统一集群环境。</p><span id="more"></span><p>节点：节点从属于环境，一个环境集下可存在多个节点。如生产环境的多个节点app1，app2<br>部署单元：部署单元由环境集，节点，服务，三部分组合而成的服务容器(通俗的描述：就是在某个环境集的某台节点部署某个服务，在docker服务下表现为服务容器，运行状态下可使用docker ps查询)</p><p><img src="http://img.struy.cn/18-12-10/936788.jpg"></p><h2 id="原有的构建步骤："><a href="#原有的构建步骤：" class="headerlink" title="原有的构建步骤："></a>原有的构建步骤：</h2><p>生产–在没有构建中心之前，服务都是在其他环境通过脚本或者jenkins构建成为镜像，再行手动填写更新服务。<br>测试–通过tscompose构建并启动服务容器，在对应的测试主机上进行反复操作。</p><h2 id="构建中心在在这中间扮演的角色："><a href="#构建中心在在这中间扮演的角色：" class="headerlink" title="构建中心在在这中间扮演的角色："></a>构建中心在在这中间扮演的角色：</h2><p>构建中心应当是完全替代jenkins进行持续集成的功能模块，在开发此模块的过程中，走了很多弯路。甚至走偏的中心思想。脱离了最初的对于环境集，部署单元的理解。</p><p>现在部署中心将与构建环境融为一体，<code>构建从部署配置中来，部署从构建结果中去</code>。而这也是在初期开发构建中心时最为为头痛的问题，如何将构建个发布结合到一起。(历史原因是部署中心走在前，对于构建的问题没有加强考虑，过于片面的理解所谓的构建)</p><h2 id="构建需要考虑的问题有以下几点："><a href="#构建需要考虑的问题有以下几点：" class="headerlink" title="构建需要考虑的问题有以下几点："></a>构建需要考虑的问题有以下几点：</h2><p>1.代码源信息描述在何处？<br>源代码信息维护在服务的基础信息中，因为不论环境如何变化，单个项目的代码源信息是不会改变的<br>2.在何处构建，在何处发布？<br>因为项目内容，环境，配置有所不同，服务在何处构建，存在区别。好比普通的sandbox上构建服务都是构建并发布。不存在运维参与升级，测试环境一个特点就是“快”（快速构建，快速发布，快速测试），针对预发布环境是“准”，预发布环境作为上线前最后一道验证环境。需要确认代码准确，并且不被其他因素所影响，比方说服务器性能等等，所以一般不会在预发布环境进行发布并部署，专门使用一台构建主机，预发布环境作为运行环境。生产环境就和预发布环境没什么区别了<br>3.代码分支如何切换？<br>在一个环境进行构建，可能需要频繁的切换分支进行构建（比方在预发布环境构建order项目分支为R_001分支），可以将分支描述在部署单元之上，一个部署单元就可以描述一个构建任务，在部署单元上配置的分支就是构建的分支<br>4.不同服务的构建方法有所不同，怎么描述构建的过程？<br>尽管各个项目的构建方式不同，如maven，sbt，npm，shell。最终都是一组指令，将这组指令描述在服务信息中</p><h2 id="构建的流程："><a href="#构建的流程：" class="headerlink" title="构建的流程："></a>构建的流程：</h2><p>1.在环境集中添加主机时，需要指定构建主机(一个环境集下面可不可以有多个构建主机？)<br>2.服务管理内描述了服务的源代码信息，构建指令，依赖服务信息<br>3.部署单元既描述部署信息(某个环境集的某台节点部署某个服务),也描述构建信息(构建某个环境的某个服务的某个分支)，通过部署单元对应的环境集查找这个环境集下已经指定的构建主机，而部署节点就是部署单元中所指定的部署节点<br>4.一个部署单元就相当于构建任务，配置完成后可在持续集成的界面查看其配置改动，开始构建即可在对应构建主机上进行构建，最后在部署节点上进行部署<br>5.针对服务依赖的管理，首先是从部署单元对应的服务信息中获得服务的依赖树，在构建执行前，查找依赖服务在部署单元中是否存在，如果存在即构建(且这个依赖服务的构建分支由所在的部署单元指定)<br>6.在部署单元进行部署配置时，填写的镜像tag统一使用<code>latest</code>，将构建所得镜像唯一的tag打包为<code>latest</code>镜像进行持续的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[A:7349d95 =&gt; A:latest]</span><br><span class="line">up -d this latest service</span><br></pre></td></tr></table></figure><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><ul><li>环境集管理可指定构建主机</li><li>构建的视图环境是类似发布部署的视图，可以选定环境集的么某个服务进行构建&#x2F;构建并部署</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;回顾原有的几个概念：&lt;br&gt;服务：微服务架构，每个项目代码库，都最终打包为一个docker镜像，而这里的服务就是描述这个镜像最基本的配置，描述一个应用最初，最抽象的状态&lt;br&gt;环境集：一个环境集合，例如测试环境中的某个sandbox环境，生产的统一集群环境。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Dapeng微服务" scheme="http://struy.cn/tags/Dapeng%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>vue实例生命周期</title>
    <link href="http://struy.cn/2018/07/15/vue-life/"/>
    <id>http://struy.cn/2018/07/15/vue-life/</id>
    <published>2018-07-15T15:00:47.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<p>vue实例生命周期</p><span id="more"></span><p><img src="http://img.struy.cn/18-7-15/23698537.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vue实例生命周期&lt;/p&gt;</summary>
    
    
    
    
    <category term="Vue" scheme="http://struy.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>maven常用插件使用范例</title>
    <link href="http://struy.cn/2018/06/26/maven-plugins-use/"/>
    <id>http://struy.cn/2018/06/26/maven-plugins-use/</id>
    <published>2018-06-26T09:35:38.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<p>maven常用插件使用范例:</p><span id="more"></span><ul><li>maven-assembly-plugin</li><li>exec-maven-plugin</li><li>docker-maven-plugin</li><li>maven-antrun-plugin</li><li>maven-jar-plugin</li><li>maven-dependency-plugin</li><li>wagon-maven-plugin</li><li>tomcat7-maven-plugin</li><li>maven-shade-plugin</li><li>git-commit-id-plugin</li><li>properties-maven-plugin</li></ul><h3 id="maven-assembly-plugin"><a href="#maven-assembly-plugin" class="headerlink" title="(maven-assembly-plugin)"></a>(maven-assembly-plugin)</h3><p>定制化打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.5&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">            &lt;manifest&gt;</span><br><span class="line">                &lt;mainClass&gt;org.struy.MainTets&lt;/mainClass&gt;</span><br><span class="line">            &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="exec-maven-plugin"><a href="#exec-maven-plugin" class="headerlink" title="(exec-maven-plugin)"></a>(exec-maven-plugin)</h3><p>执行本地脚本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.0&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;build-docker-image&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;exec&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;executable&gt;$&#123;basedir&#125;/build.sh&lt;/executable&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="docker-maven-plugin"><a href="#docker-maven-plugin" class="headerlink" title="(docker-maven-plugin)"></a>(docker-maven-plugin)</h3><p>构建docker镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.4.10&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;imageName&gt;docker.dapeng.example/hello-service:1.0-SNAPSHOT&lt;/imageName&gt;</span><br><span class="line">        &lt;dockerDirectory&gt;$&#123;basedir&#125;/docker&lt;/dockerDirectory&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="maven-antrun-plugin"><a href="#maven-antrun-plugin" class="headerlink" title="(maven-antrun-plugin)"></a>(maven-antrun-plugin)</h3><p>在maven中运行Ant任务，比如在打包阶段，对文件进行复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;copy files&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;!-- copy child&#x27;s output files into target/docker --&gt;</span><br><span class="line">                &lt;tasks&gt;</span><br><span class="line">                    &lt;copy todir=&quot;$&#123;basedir&#125;/docker/$&#123;project.artifactId&#125;/&quot;&gt;</span><br><span class="line">                        &lt;fileset dir=&quot;$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;&quot;/&gt;</span><br><span class="line">                    &lt;/copy&gt;</span><br><span class="line">                &lt;/tasks&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;run&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;clean up the docker folder&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;clean&lt;/phase&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;!-- delete folder under docker --&gt;</span><br><span class="line">                &lt;tasks&gt;</span><br><span class="line">                    &lt;delete dir=&quot;$&#123;basedir&#125;/docker/$&#123;project.artifactId&#125;&quot;/&gt;</span><br><span class="line">                &lt;/tasks&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;run&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="maven-jar-plugin"><a href="#maven-jar-plugin" class="headerlink" title="(maven-jar-plugin)"></a>(maven-jar-plugin)</h3><p>jar指定目录，设定manifest的参数，或指定运行的Main class，还有依赖的jar包，加入classpath中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;/&lt;/outputDirectory&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="maven-dependency-plugin"><a href="#maven-dependency-plugin" class="headerlink" title="(maven-dependency-plugin)"></a>(maven-dependency-plugin)</h3><p>复制依赖的jar包到指定的文件夹里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;copy-dependencies&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;prepare-package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;/</span><br><span class="line">                &lt;/outputDirectory&gt;</span><br><span class="line">                &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt;</span><br><span class="line">                &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt;</span><br><span class="line">                &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt;</span><br><span class="line">                &lt;excludeArtifactIds&gt;dapeng-core&lt;/excludeArtifactIds&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="wagon-maven-plugin"><a href="#wagon-maven-plugin" class="headerlink" title="(wagon-maven-plugin)"></a>(wagon-maven-plugin)</h3><p>用于一键部署，把本地打包的jar文件，上传到远程服务器上，并执行服务器上的shell命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;wagon-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;serverId&gt;crawler&lt;/serverId&gt;</span><br><span class="line">        &lt;fromDir&gt;target&lt;/fromDir&gt;</span><br><span class="line">        &lt;includes&gt;*.jar,*.properties,*.sh&lt;/includes&gt;</span><br><span class="line">        &lt;url&gt;sftp://59.110.162.178/home/zhangxianhe&lt;/url&gt;</span><br><span class="line">        &lt;commands&gt;</span><br><span class="line">            &lt;command&gt;chmod 755 /home/zhangxianhe/update.sh&lt;/command&gt;</span><br><span class="line">            &lt;command&gt;/home/zhangxianhe/update.sh&lt;/command&gt;</span><br><span class="line">        &lt;/commands&gt;</span><br><span class="line">        &lt;displayCommandOutputs&gt;true&lt;/displayCommandOutputs&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="tomcat7-maven-plugin"><a href="#tomcat7-maven-plugin" class="headerlink" title="(tomcat7-maven-plugin)"></a>(tomcat7-maven-plugin)</h3><p>用于远程部署Java Web项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;url&gt;http://59.110.162.178:8080/manager/text&lt;/url&gt;</span><br><span class="line">        &lt;username&gt;linjinbin&lt;/username&gt;</span><br><span class="line">        &lt;password&gt;linjinbin&lt;/password&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="maven-shade-plugin"><a href="#maven-shade-plugin" class="headerlink" title="(maven-shade-plugin)"></a>(maven-shade-plugin)</h3><p>用于把多个jar包，打成1个jar包一般Java项目都会依赖其他第三方jar包，最终打包时，希望把其他jar包包含在一个jar包里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;transformers&gt;</span><br><span class="line">                    &lt;transformer</span><br><span class="line">                        implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                        &lt;manifestEntries&gt;</span><br><span class="line">                            &lt;Main-Class&gt;com.meiyou.topword.App&lt;/Main-Class&gt;</span><br><span class="line">                            &lt;X-Compile-Source-JDK&gt;$&#123;maven.compile.source&#125;&lt;/X-Compile-Source-JDK&gt;</span><br><span class="line">                            &lt;X-Compile-Target-JDK&gt;$&#123;maven.compile.target&#125;&lt;/X-Compile-Target-JDK&gt;</span><br><span class="line">                        &lt;/manifestEntries&gt;</span><br><span class="line">                    &lt;/transformer&gt;</span><br><span class="line">                &lt;/transformers&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="git-commit-id-plugin"><a href="#git-commit-id-plugin" class="headerlink" title="(git-commit-id-plugin)"></a>(git-commit-id-plugin)</h3><p>获取git的commit-id插件,比如在打包jar包和构建docker镜像时用于区分版本(配合properties-maven-plugin 可使用${git.commit.id.abbrev}使用此变量在其他插件中获取commit-id)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;get-the-git-infos&lt;/id&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;revision&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line"></span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;dotGitDirectory&gt;$&#123;project.basedir&#125;/.git&lt;/dotGitDirectory&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- @since 2.2.0 --&gt;</span><br><span class="line">        &lt;dateFormatTimeZone&gt;$&#123;user.timezone&#125;&lt;/dateFormatTimeZone&gt;</span><br><span class="line"></span><br><span class="line">        &lt;generateGitPropertiesFile&gt;true&lt;/generateGitPropertiesFile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;generateGitPropertiesFilename&gt;$&#123;project.build.directory&#125;/git.ini&lt;/generateGitPropertiesFilename&gt;</span><br><span class="line"></span><br><span class="line">        &lt;format&gt;properties&lt;/format&gt;</span><br><span class="line"></span><br><span class="line">        &lt;skipPoms&gt;false&lt;/skipPoms&gt;</span><br><span class="line"></span><br><span class="line">        &lt;injectAllReactorProjects&gt;false&lt;/injectAllReactorProjects&gt;</span><br><span class="line">        &lt;skip&gt;false&lt;/skip&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- @since 2.1.12 --&gt;</span><br><span class="line">        &lt;runOnlyOnce&gt;false&lt;/runOnlyOnce&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- @since 2.1.9 --&gt;</span><br><span class="line">        &lt;includeOnlyProperties&gt;</span><br><span class="line">            &lt;includeOnlyProperty&gt;^git.branch$&lt;/includeOnlyProperty&gt;</span><br><span class="line">            &lt;includeOnlyProperty&gt;^git.commit.id.abbrev$&lt;/includeOnlyProperty&gt;</span><br><span class="line">        &lt;/includeOnlyProperties&gt;</span><br><span class="line"></span><br><span class="line">        &lt;useNativeGit&gt;true&lt;/useNativeGit&gt;</span><br><span class="line"></span><br><span class="line">        &lt;abbrevLength&gt;7&lt;/abbrevLength&gt;</span><br><span class="line">        &lt;commitIdGenerationMode&gt;flat&lt;/commitIdGenerationMode&gt;</span><br><span class="line"></span><br><span class="line">        &lt;gitDescribe&gt;</span><br><span class="line">            &lt;skip&gt;true&lt;/skip&gt;</span><br><span class="line">            &lt;always&gt;false&lt;/always&gt;</span><br><span class="line">            &lt;abbrev&gt;7&lt;/abbrev&gt;</span><br><span class="line">            &lt;dirty&gt;-dirty&lt;/dirty&gt;</span><br><span class="line">            &lt;match&gt;*&lt;/match&gt;</span><br><span class="line">            &lt;forceLongFormat&gt;false&lt;/forceLongFormat&gt;</span><br><span class="line">        &lt;/gitDescribe&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="properties-maven-plugin"><a href="#properties-maven-plugin" class="headerlink" title="(properties-maven-plugin)"></a>(properties-maven-plugin)</h3><p>读取指定properties(这里是配合git-commit-id-plugin 以读取commit-id信息)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;properties-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;read-project-properties&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;files&gt;</span><br><span class="line">                    &lt;file&gt;$&#123;project.build.directory&#125;/git.ini&lt;/file&gt;</span><br><span class="line">                &lt;/files&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;maven常用插件使用范例:&lt;/p&gt;</summary>
    
    
    
    
    <category term="Maven" scheme="http://struy.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>无问西东</title>
    <link href="http://struy.cn/2018/05/28/wu-wen-xi-dong/"/>
    <id>http://struy.cn/2018/05/28/wu-wen-xi-dong/</id>
    <published>2018-05-27T16:39:41.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>他们的爱与风华，只问自由，只问盛放，只问深情，只问初心，只问勇敢，无问西东。</p></blockquote><ul><li>把自己交给繁忙，得到的是踏实，却不是真实</li></ul><span id="more"></span><p><img src="http://img.struy.cn/18-5-28/20859131.jpg" alt="无问西东"></p><ul><li>看到的和听到的，经常会令你们沮丧，世俗这样强大，强大到生不出改变它们的念头。可是无论外界的社会如何跌宕起伏，都对自己真诚，坚守原则。内心没有了杂念和疑问，才能勇往直前</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;他们的爱与风华，只问自由，只问盛放，只问深情，只问初心，只问勇敢，无问西东。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;把自己交给繁忙，得到的是踏实，却不是真实&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="电影" scheme="http://struy.cn/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>白话tscompose</title>
    <link href="http://struy.cn/2018/05/28/tscompose-bai-hua/"/>
    <id>http://struy.cn/2018/05/28/tscompose-bai-hua/</id>
    <published>2018-05-27T16:36:57.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="白话tscompose"><a href="#白话tscompose" class="headerlink" title="白话tscompose"></a>白话tscompose</h3><p>需要说明几点:<br>1.tscompose基于docker-compose进行进一步定制,使其能完成dapeng的服务开发&#x3D;&gt;构建&#x3D;&gt;发布&#x3D;&gt;启动整套流程<br>2.scompose的每个命令可以看作是一组命令的集合,只是简化了操作,做了部分逻辑优化<br>3.tscompose在使用前需要设置两个环境变量</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodeName=sandbox           nodeName,从字面来理解是节点名称,这个名称是至关重要的,下面的多项配置都会使用到此环境变量</span><br><span class="line">COMPOSE_WORKSPACE=/data/workspace/      COMPOSE_WORKSPACE的指定了在tscompose使用时(特别是在测试阶段需要频繁构建)，服务源代码存储的位置</span><br></pre></td></tr></table></figure><p>ts目录结构树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">➜  tscompose git:(master) ✗ tree .</span><br><span class="line">├── .envs    此目录下都是环境变量</span><br><span class="line">│   ├── application.env    一般情况下服务的所有数据库连接信息都在本文件内(文件内容可由 initEnvs/develop.env初始化)</span><br><span class="line">│   └── common.env         针对服务的一些通用配置参数，通常是很少变动的配置(如通用的环境变量,文件内容可由initEnvs/common.env初始化)</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .local-sandbox.ini     需要手动建立,文件内容为当前节点ip地址(host_ip=xxxx),建立规则为[.local-&#123;nodeName&#125;.ini],其中&#123;nodeName&#125;就是环境变量中的nodeName的值</span><br><span class="line">├── .local.gitid.ini       记录服务源代码的最后一次commit对应的id前7位(由./scompose s-update-gid更新此文件)</span><br><span class="line">├── .local.ini             文件内容可由initEnvs/develop.ini 或者 production.ini 初始化</span><br><span class="line">├── .version.ini           记录升级内容</span><br><span class="line">├── README.md</span><br><span class="line">├── dc-all.yml             所有的服务(容器)配置都会在此文件中,具体配置内容下面详解</span><br><span class="line">├── dc-app-2.yml</span><br><span class="line">├── dc-ci.yml</span><br><span class="line">├── dc-demo1.yml</span><br><span class="line">├── dc-local-sandbox.yml</span><br><span class="line">├── dc-monitor.yml</span><br><span class="line">├── dc-pos-demo.yml</span><br><span class="line">├── dc-proxy.yml           文件内容决定了当前节点启动的服务有哪些,文件建立规则dc-&#123;nodename&#125;.yml</span><br><span class="line">├── dc-sandbox1.yml</span><br><span class="line">├── dc-sandbox2.yml</span><br><span class="line">├── dc-sandbox3.yml</span><br><span class="line">├── dc-sandbox4.yml</span><br><span class="line">├── dc-web.yml</span><br><span class="line">├── initEnvs       针对所有的节点，此文件夹内文件可初始化(.envs/application.env &amp;&amp; .envs/common.env &amp;&amp; .local.ini)三个文件</span><br><span class="line">│   ├── common.env         当执行sh prepare.sh develop 或者 production 将copy此文件到.envs/common.env</span><br><span class="line">│   ├── develop.env        当执行sh prepare.sh develop 或者 production 将copy此文件到.envs/application.env</span><br><span class="line">│   ├── develop.ini        当执行sh prepare.sh develop 将copy此文件到.local.ini</span><br><span class="line">│   └── production.ini     当执行sh prepare.sh production 将copy此文件到.local.ini</span><br><span class="line">├── prepare.sh             通常用于初始化配置,命令 sh prepare.sh [develop|production|test]</span><br><span class="line">├── scompose               核心脚本,所有基础命令入口，./scompose 可查看命令帮助</span><br><span class="line">└── shell                  一些常用脚本，现未使用</span><br><span class="line">    ├── allApiProjects.log</span><br><span class="line">    ├── cleanImages.sh</span><br><span class="line">    ├── convertFilesToShell.sh</span><br><span class="line">    ├── installAllApiProjects.sh</span><br><span class="line">    ├── pullBaseImage.sh</span><br><span class="line">    ├── rebuildLocalServices.sh</span><br><span class="line">    ├── runUnittest.sh</span><br><span class="line">    └── updatedApi.log</span><br></pre></td></tr></table></figure><p>常见使用场景<br>~</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;白话tscompose&quot;&gt;&lt;a href=&quot;#白话tscompose&quot; class=&quot;headerlink&quot; title=&quot;白话tscompose&quot;&gt;&lt;/a&gt;白话tscompose&lt;/h3&gt;&lt;p&gt;需要说明几点:&lt;br&gt;1.tscompose基于docker-compose进行进一步定制,使其能完成dapeng的服务开发&amp;#x3D;&amp;gt;构建&amp;#x3D;&amp;gt;发布&amp;#x3D;&amp;gt;启动整套流程&lt;br&gt;2.scompose的每个命令可以看作是一组命令的集合,只是简化了操作,做了部分逻辑优化&lt;br&gt;3.tscompose在使用前需要设置两个环境变量&lt;/p&gt;</summary>
    
    
    
    
    <category term="Dapeng微服务" scheme="http://struy.cn/tags/Dapeng%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Docker" scheme="http://struy.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>influxdb常用操作</title>
    <link href="http://struy.cn/2018/04/30/influxdb-commons-action/"/>
    <id>http://struy.cn/2018/04/30/influxdb-commons-action/</id>
    <published>2018-04-30T03:32:50.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="哪些情况下用tag"><a href="#哪些情况下用tag" class="headerlink" title="哪些情况下用tag"></a>哪些情况下用tag</h3><p>一般来说，你的查询可以指引你哪些数据放在tag中，哪些放在field中。</p><ul><li>把你经常查询的字段作为tag</li><li>如果你要对其使用GROUP BY()，也要放在tag中</li><li>如果你要对其使用InfluxQL函数，则将其放到field中</li><li>如果你需要存储的值不是字符串，则需要放到field中，因为tag value只能是字符串</li></ul><span id="more"></span><h3 id="终端操作数据库"><a href="#终端操作数据库" class="headerlink" title="终端操作数据库"></a>终端操作数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">查看所有数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">// 添加数据库</span><br><span class="line">create database [database]</span><br><span class="line"></span><br><span class="line">// 删除数据库</span><br><span class="line">drop datebase [databese]</span><br><span class="line"></span><br><span class="line">// 指定数据库</span><br><span class="line">use [database]</span><br><span class="line"></span><br><span class="line">// 查看指定数据库下所有measurement</span><br><span class="line">show measurements</span><br><span class="line"></span><br><span class="line">// 删除measurement</span><br><span class="line">drop measurement [measurement]</span><br><span class="line"></span><br><span class="line">// 用drop从索引中删除series</span><br><span class="line">drop series from &lt;measurement_name[,measurement_name]&gt; where &lt;tag_key&gt;=&#x27;&lt;tag_value&gt;&#x27;</span><br><span class="line"></span><br><span class="line">// 从单个measurement删除所有series：</span><br><span class="line">drop series from &quot;h2o_feet&quot;</span><br><span class="line"></span><br><span class="line">//从单个measurement删除指定tag的series：</span><br><span class="line">drop series from &quot;h2o_feet&quot; where &quot;location&quot; = &#x27;santa_monica&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从数据库删除有指定tag的所有measurement中的所有数据：</span><br><span class="line">drop series where &quot;location&quot; = &#x27;santa_monica&#x27;</span><br><span class="line"></span><br><span class="line">//用delete删除series</span><br><span class="line">delete from &lt;measurement_name&gt; where [&lt;tag_key&gt;=&#x27;&lt;tag_value&gt;&#x27;] | [&lt;time interval&gt;]</span><br><span class="line"></span><br><span class="line">//删除measurementh2o_feet的所有相关数据：</span><br><span class="line">delete from &quot;h2o_feet&quot;</span><br><span class="line"></span><br><span class="line">// 删除measurementh2o_quality并且tagrandtag等于3的所有数据：</span><br><span class="line">delete from &quot;h2o_quality&quot; where &quot;randtag&quot; = &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">// 删除数据库中2016年一月一号之前的所有数据：</span><br><span class="line">delete where time &lt; &#x27;2016-01-01&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>终端插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"></span><br><span class="line">&lt;measurement&gt;[,&lt;tag-key&gt;=&lt;tag-value&gt;...] &lt;field-key&gt;=&lt;field-value&gt;[,&lt;field2-key&gt;=&lt;field2-value&gt;...] [unix-nano-timestamp]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">insert cpu,host=servera,region=us_west value=0.64</span><br><span class="line"></span><br><span class="line">insert temperature,machine=unit42,type=assembly external=25,internal=37</span><br></pre></td></tr></table></figure><h3 id="数据写入-网络通讯"><a href="#数据写入-网络通讯" class="headerlink" title="数据写入(网络通讯)"></a>数据写入(网络通讯)</h3><ul><li>使用http接口创建&#x2F;删除数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -xpost http://localhost:8086/query --data-urlencode &quot;q=create database dapengstate&quot;</span><br><span class="line"></span><br><span class="line">curl -i -xpost http://localhost:8086/query --data-urlencode &quot;q=drop database dapengstate&quot;</span><br></pre></td></tr></table></figure><ul><li>使用http接口写数据</li></ul><blockquote><p>通过http接口post数据到&#x2F;write路径是我们往influxdb写数据的主要方式。下面的例子写了一条数据到mydb数据库。这条数据的组成部分是measurement为cpu_load_short，tag的key为host和region，对应tag的value是server01和us-west，field的key是value，对应的数值为0.64，而时间戳是1434055562000000000</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -xpost &#x27;http://localhost:8086/write?db=dapengstate&#x27; --data-binary &#x27;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&#x27;</span><br></pre></td></tr></table></figure><ul><li>写入多个点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -xpost &#x27;http://localhost:8086/write?db=mydb&#x27; --data-binary &#x27;cpu_load_short,host=server02 value=0.67</span><br><span class="line">cpu_load_short,host=server02,region=us-west value=0.55 1422568543702900257</span><br><span class="line">cpu_load_short,direction=in,host=server01,region=us-west value=2.0 1422568543702900257&#x27;</span><br></pre></td></tr></table></figure><ul><li>通过文件写入数据<blockquote><p>可以通过curl的@filename来写入文件中的数据，且这个文件里的数据的格式需要满足influxdb那种行的语法。</p></blockquote></li></ul><p><code>cup_data.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpu_load_short,host=server02 value=0.67</span><br><span class="line">cpu_load_short,host=server02,region=us-west value=0.55 1422568543702900257</span><br><span class="line">cpu_load_short,direction=in,host=server01,region=us-west value=2.0 1422568543702900257</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -xpost &#x27;http://localhost:8086/write?db=mydb&#x27; --data-binary @cpu_data.txt</span><br></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -g &#x27;http://localhost:8086/query?pretty=true&#x27; --data-urlencode &quot;db=mydb&quot; --data-urlencode &quot;q=select \&quot;value\&quot; from \&quot;cpu_load_short\&quot; where \&quot;region\&quot;=&#x27;us-west&#x27;&quot;</span><br></pre></td></tr></table></figure><p>返回值(json)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;results&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;statement_id&quot;: 0,</span><br><span class="line">            &quot;series&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;cpu_load_short&quot;,</span><br><span class="line">                    &quot;columns&quot;: [</span><br><span class="line">                        &quot;time&quot;,</span><br><span class="line">                        &quot;value&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;values&quot;: [</span><br><span class="line">                        [</span><br><span class="line">                            &quot;2015-06-11t20:46:02z&quot;,</span><br><span class="line">                            0.64</span><br><span class="line">                        ]</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>pretty&#x3D;ture参数在url里面，是为了让返回的json格式化。这在调试或者是直接用curl的时候很有用，但在生产上不建议使用，因为这样会消耗不必要的网络带宽。</p></li><li><p>多个查询</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -g &#x27;http://localhost:8086/query?pretty=true&#x27; --data-urlencode &quot;db=mydb&quot; --data-urlencode &quot;q=select \&quot;value\&quot; from \&quot;cpu_load_short\&quot; where \&quot;region\&quot;=&#x27;us-west&#x27;;select count(\&quot;value\&quot;) from \&quot;cpu_load_short\&quot; where \&quot;region\&quot;=&#x27;us-west&#x27;&quot;</span><br></pre></td></tr></table></figure><h3 id="数据采样-x2F-数据保留策略"><a href="#数据采样-x2F-数据保留策略" class="headerlink" title="数据采样&#x2F;数据保留策略"></a>数据采样&#x2F;数据保留策略</h3><p>需求：</p><ul><li><p>自动将十秒间隔数据聚合到30分钟的间隔数据</p></li><li><p>自动删除两个小时以上的原始10秒间隔数据</p></li><li><p>自动删除超过52周的30分钟间隔数据<br>如果我们写数据的时候没有指定rp的话，influxdb会使用默认的rp</p></li><li><p>创建一个保留两小时的数据的rp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create retention policy &quot;two_hours&quot; on &quot;food_data&quot; duration 2h replication 1 default</span><br></pre></td></tr></table></figure><blockquote><p>创建数据库时，influxdb会自动生成一个叫做autogen的rp，并作为数据库的默认rp，autogen这个rp会永远保留数据。在输入上面的命令之后，two_hours会取代autogen作为food_data的默认rp。</p></blockquote></li><li><p>创建一个保留52周数据的RP</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create retention policy &quot;a_year&quot; on &quot;food_data&quot; duration 52w replication 1</span><br></pre></td></tr></table></figure><h3 id="创建CQ-Continuous-Query-x2F-连续查询"><a href="#创建CQ-Continuous-Query-x2F-连续查询" class="headerlink" title="创建CQ(Continuous Query&#x2F;连续查询)"></a>创建CQ(Continuous Query&#x2F;连续查询)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create continuous query &quot;cq_30m&quot; on &quot;food_data&quot; begin</span><br><span class="line">  select mean(&quot;website&quot;) as &quot;mean_website&quot;,mean(&quot;phone&quot;) as &quot;mean_phone&quot;</span><br><span class="line">  into &quot;a_year&quot;.&quot;downsampled_orders&quot;</span><br><span class="line">  from &quot;orders&quot;</span><br><span class="line">  group by time(30m)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>注意到我们在into语句中使用了”<retention_policy>“.”<measurement>“这样的语句，当要写入到非默认的rp时，就需要这样的写法。</p></blockquote><blockquote><p>上面创建了一个叫做cq_30m的cq作用于food_data数据库上。cq_30m告诉influxdb每30分钟计算一次measurement为orders并使用默认rptow_hours的字段website和phone的平均值，然后把结果写入到rp为a_year，两个字段分别是mean_website和mean_phone的measurement名为downsampled_orders的数据中。influxdb会每隔30分钟跑对之前30分钟的数据跑一次这个查询。</p></blockquote><ul><li>创建数据库时指定保留策略</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database &quot;noaa_water_database&quot; with duration 3d replication 1 shard duration 1h name &quot;liquid&quot;</span><br></pre></td></tr></table></figure><blockquote><p>该语句创建了一个叫做noaa_water_database的数据库，并且创建了liquid作为数据库的默认保留策略，其持续时间为3天，副本数是1，shard group的持续时间为一个小时。</p></blockquote><ul><li>修改保留策略</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter retention policy &lt;retention_policy_name&gt; on &lt;database_name&gt; duration &lt;duration&gt; replication &lt;n&gt; shard duration &lt;duration&gt; default</span><br></pre></td></tr></table></figure><p>创建保留策略what_is_time其持续时间为两天</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create retention policy &quot;what_is_time&quot; on &quot;noaa_water_database&quot; duration 2d replication 1</span><br></pre></td></tr></table></figure><p>修改what_is_time的持续时间为3个星期，shard group的持续时间为30分钟，并将其作为数据库noaa_water_database的默认保留策略：+</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter retention policy &quot;what_is_time&quot; on &quot;noaa_water_database&quot; duration 3w shard duration 30m default</span><br></pre></td></tr></table></figure><ul><li>删除保留策略</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop retention policy &lt;retention_policy_name&gt; on &lt;database_name&gt;</span><br></pre></td></tr></table></figure><h3 id="如何查看InfluxDB的版本"><a href="#如何查看InfluxDB的版本" class="headerlink" title="如何查看InfluxDB的版本"></a>如何查看InfluxDB的版本</h3><p>终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd version</span><br></pre></td></tr></table></figure><p>curl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i &#x27;http://localhost:8086/ping&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;哪些情况下用tag&quot;&gt;&lt;a href=&quot;#哪些情况下用tag&quot; class=&quot;headerlink&quot; title=&quot;哪些情况下用tag&quot;&gt;&lt;/a&gt;哪些情况下用tag&lt;/h3&gt;&lt;p&gt;一般来说，你的查询可以指引你哪些数据放在tag中，哪些放在field中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把你经常查询的字段作为tag&lt;/li&gt;
&lt;li&gt;如果你要对其使用GROUP BY()，也要放在tag中&lt;/li&gt;
&lt;li&gt;如果你要对其使用InfluxQL函数，则将其放到field中&lt;/li&gt;
&lt;li&gt;如果你需要存储的值不是字符串，则需要放到field中，因为tag value只能是字符串&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Influxdb" scheme="http://struy.cn/tags/Influxdb/"/>
    
    <category term="时序数据库" scheme="http://struy.cn/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>事件总线EventBus实现架构原理分析</title>
    <link href="http://struy.cn/2018/03/16/eventbus-archtech-0316/"/>
    <id>http://struy.cn/2018/03/16/eventbus-archtech-0316/</id>
    <published>2018-03-16T15:49:49.000Z</published>
    <updated>2023-04-27T10:17:01.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>事件总线(EventBus)设计初衷是解耦系统模块，将系统中的各类业务操作抽象为事件模型。我们把产生事件的部分称之为事件的发送者(Publisher)，消费事件的部分称之为订阅者(Subcriber)。</p></blockquote><span id="more"></span><p><a href="https://github.com/dapeng-soa">@大鹏开源</a>:别看我有点萌，我可以秒变大鹏。<br><img src="http://upload-images.jianshu.io/upload_images/6393906-b7ba572342b3e4ba..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="大鹏鸟"></p><h1 id="DDD领域事件架构简析"><a href="#DDD领域事件架构简析" class="headerlink" title="DDD领域事件架构简析"></a>DDD领域事件架构简析</h1><p>领域事件是领域驱动设计(Domain Driven Design，简称DDD)中的一个概念，领域模型的变化会产生领域事件，事件的产生往往伴随着相应的动作。例如，用户在完成注册后，系统会发出一封带有确认信息的邮件到用户的邮箱。有了领域事件，每个领域本身就只需要关系其自己的业务逻辑，并在处理完自身逻辑的同时抛出相应的领域事件。对这些领域事件感兴趣的业务方可以订阅该事件，然后进行后续的处理。</p><p>结合领域事件和EventBus，我们来看一下基于Today中台架构的EventBus架构模型：</p><p><img src="https://upload-images.jianshu.io/upload_images/6393906-a0cdb1c3e8040895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eventbus模型.png"></p><p>领域事件产生后会有监听者进行事件监听。在如此众多的事件中，需要一个消息总线对消息进行统一的管理。消息总线的作用有：</p><p> 1.一个大的领域内的各小模块之间的事件的触发和订阅；</p><p> 2.跨领域（跨JVM进程）之间的事件订阅。</p><p>首先领域内某个方法触发事件，例如<code>registerUser()</code>方法执行成功后，会发布一个用户创建的事件。这时候，我们只需要调用<code>EventBus.fireEvent()</code>方法，就会将事件发布出去，在EventBus内部，如果本领域内有订阅者订阅此事件，Eventbus就会匹配消息的类型，然后进行相应事件的逻辑处理，这样就做到了领域内的事件监听和处理。</p><p>在这种情况下，事件的发布和订阅是强一致性的，两者在同一个处理过程中，当出现错误，触发事件方和订阅方的数据会一起回滚。</p><h2 id="不管是领域内事件还是跨领域事件，在EventBus触发事件之后，都会选择将消息持久化到业务数据库。"><a href="#不管是领域内事件还是跨领域事件，在EventBus触发事件之后，都会选择将消息持久化到业务数据库。" class="headerlink" title="不管是领域内事件还是跨领域事件，在EventBus触发事件之后，都会选择将消息持久化到业务数据库。"></a>不管是领域内事件还是跨领域事件，在EventBus触发事件之后，都会选择将消息持久化到业务数据库。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def fireEvent(event: Any): Unit = &#123;</span><br><span class="line">  // 本地事件分发处理</span><br><span class="line">  dispatchEvent(event)</span><br><span class="line"> //持久化事件</span><br><span class="line">  persistenceEvent(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="跨领域事件消息保障"><a href="#跨领域事件消息保障" class="headerlink" title="跨领域事件消息保障"></a>跨领域事件消息保障</h1><p>跨领域消息需要通过消息中间件(MQ)来进行传递，目的就是解除系统间的强依赖性，解耦业务模块。</p><p>我们的事件总线发布的跨领域（系统）消息，是通过kafka这款消息中间件来进行存储转发的。因为每一条事件消息对业务系统都十分重要，我们要确保发送消息不能丢失，并最终能够被订阅者订阅到。</p><h2 id="kafka对消息发送的保障"><a href="#kafka对消息发送的保障" class="headerlink" title="kafka对消息发送的保障"></a>kafka对消息发送的保障</h2><p>Kafka的语义很直接，当发布一条消息时，<code>kafka broker</code>收到后并 <code>committed</code>到了日志，那么在<code>broker</code>看来, 这个消息已经发布成功了，同时会有一个ack消息返回给生产者。<br/></p><p>当网络不可靠时, 我们会碰到这样一种情形：生产者发送消息时发生网络错误，这时将无法确定错误发生在broker收到消息前还是在收到消息后(返回ack丢失)。</p><h3 id="Kafka的三种语义"><a href="#Kafka的三种语义" class="headerlink" title="Kafka的三种语义"></a>Kafka的三种语义</h3><ul><li>At most once  <br/><br>最多一次：消息可能丢失，但绝不会重发。</li><li>At least once <br/><br>至少一次：消息绝不会丢失，但有可能重新发送。</li></ul><ul><li>Exactly once  <br/><br>正好一次：这是我们真正想要的，每个消息传递一次且仅一次。</li></ul><p>这里我们结合上述三种语义并以发送端（生产者）和接收端（消费者）对消息消费语义的保障分别进行探讨。可分解成两个问题：发送消息时的持久性保障和消费消息的保障。</p><h2 id="生产者端（Producer）消息保障"><a href="#生产者端（Producer）消息保障" class="headerlink" title="生产者端（Producer）消息保障"></a>生产者端（Producer）消息保障</h2><ul><li>最多一次：业务系统创建kafka生产者实例时，配置消息发送重试次数为0，如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties.put(retries, 0);</span><br></pre></td></tr></table></figure><p>当消息发送失败时，不会再尝试进行消息发送，这样虽然保证了消息不会重复发送，但是有可能会丢失消息，这是系统不能容忍的。</p><ul><li>至少一次：创建kafka生产者实例时，配置重试次数大于等于1，如下配置就是重试2次，如果生产者连续发送消息成功而没有收到ack，就会重试两次。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties.put(retries, 2);</span><br></pre></td></tr></table></figure></li><li>正好一次：在kafka新版中，增加了事务消息发送功能并支持发送消息的幂等性配置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties.put(enable.idempotence, &quot;true&quot;);</span><br></pre></td></tr></table></figure>这样kafka在至少一次语义的基础上，同时保证重复发送的消息不会导致日志重复，完美做到了发送端正好一次。</li></ul><p>它的原理就是<code>kafka-broker</code>为每一个生产者分配了一个<code>PID</code>，以便区分不同的生产者实例，当然这个<code>PID</code>对用户不透明，用户无需进行配置。开启了消息幂等后，producer在发送每条消息时，都会带上一个序列号(sequnceId)，这样可以在重复发送时根据序列号进行去重。</p><h2 id="消费者端（Consumer）消息保障"><a href="#消费者端（Consumer）消息保障" class="headerlink" title="消费者端（Consumer）消息保障"></a>消费者端（Consumer）消息保障</h2><ul><li>消费者接收到broker的消息后，会提交偏移量到broker上来表示消息消费成功。</li><li>我们将消费者配置为手动提交偏移量，在整个消费消息逻辑处理完成，并没有抛出异常后，手动提交偏移量。</li><li>如果偏移量未成功提交，消息将会再次发送给消费者端，这样就能够保障消息不会丢失。</li></ul><hr><h1 id="EventBus（事件总线）收发消息具体实现"><a href="#EventBus（事件总线）收发消息具体实现" class="headerlink" title="EventBus（事件总线）收发消息具体实现"></a>EventBus（事件总线）收发消息具体实现</h1><h2 id="EventBus生产端（Producer）"><a href="#EventBus生产端（Producer）" class="headerlink" title="EventBus生产端（Producer）"></a>EventBus生产端（Producer）</h2><h3 id="实现生产者端至少一次"><a href="#实现生产者端至少一次" class="headerlink" title="实现生产者端至少一次"></a>实现生产者端至少一次</h3><p>我们也会考虑这样一种情况，当业务系统需要进行批量消息发送时，如果中途某条消息发送失败后，需要之前发送成功的消息一起回滚，类似于数据库上的事务回滚。</p><h4 id="生产者配置"><a href="#生产者配置" class="headerlink" title="生产者配置"></a>生产者配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">properties.put(&quot;transactional.id&quot;,&quot;GOODS_1213&quot;);</span><br><span class="line">properties.put(&quot;enable.idempotence&quot;, &quot;true&quot;);</span><br></pre></td></tr></table></figure><ul><li>首先kafka对事务消息的支持前提是，需要为每个生产者实例显式的配置唯一的事务id号（如上配置），</li><li>其次需要将kafka消息幂等功能设置为true。</li></ul><p>通过这样的配置之后，消息在批量进行发送出现异常时，放弃当前事务即可。<br>我们实现的<code>eventbus</code>事务发送端代码如下:</p><h4 id="创建事务生产者"><a href="#创建事务生产者" class="headerlink" title="创建事务生产者"></a>创建事务生产者</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private def initTransProducer(transId: String): Unit = &#123;</span><br><span class="line">    val builder = KafkaConfigBuilder.defaultProducer</span><br><span class="line">    val properties = builder</span><br><span class="line">      .withKeySerializer(classOf[LongSerializer])</span><br><span class="line">      .withValueSerializer(classOf[ByteArraySerializer])</span><br><span class="line">      .bootstrapServers(serverHost)</span><br><span class="line">      .withTransactions(transId)</span><br><span class="line">      .withIdempotence(&quot;true&quot;) //幂等性保证</span><br><span class="line">      .build</span><br><span class="line"></span><br><span class="line">    producer = new KafkaProducer[Long, Array[Byte]](properties)</span><br><span class="line">    //初始化事务</span><br><span class="line">    producer.initTransactions()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量消息发送"><a href="#批量消息发送" class="headerlink" title="批量消息发送"></a>批量消息发送</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def batchSend(topic: String, eventMessage: util.List[EventStore]): Unit = &#123;</span><br><span class="line">try &#123;</span><br><span class="line">      producer.beginTransaction()</span><br><span class="line">      eventMessage.forEach((eventStore: EventStore) =&gt; &#123;</span><br><span class="line">        producer.send(new ProducerRecord[Long, Array[Byte]](topic, eventStore.id, eventStore.eventBinary), (metadata: RecordMetadata, exception: Exception) =&gt; &#123;</span><br><span class="line">          logger.info(</span><br><span class="line">            s&quot;&quot;&quot;in transaction per msg ,send message to broker successful,</span><br><span class="line">        id: $&#123;eventStore.id&#125;, topic: $&#123;metadata.topic&#125;, offset: $&#123;metadata.offset&#125;, partition: $&#123;metadata.partition&#125;&quot;&quot;&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      //没有异常，提交事务</span><br><span class="line">producer.commitTransaction()</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case e: Exception =&gt;</span><br><span class="line">      //回滚事务</span><br><span class="line">        producer.abortTransaction()</span><br><span class="line">        logger.error(e.getMessage, e)</span><br><span class="line">        logger.error(&quot;send message failed,topic: &#123;&#125;&quot;, topic)</span><br><span class="line">        throw e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面代码能够保障在批量发送消息时的事务一致性：要么消息全部发送成功，提交事务；如果出现一条失败，则事务回滚。</p><p>当然，为了配合事务消息，消费端需要在创建kafka消费者实例时，配置消息获取的隔离级别为<code>read_committed</code>（读取已经提交的消息）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties.put(&quot;isolation.level&quot;, &quot;read_committed&quot;);</span><br></pre></td></tr></table></figure><p>这样既可以保障事务消息的发送，又能保障幂等性，在消息发送端不考虑非常极端的情况下，是已经做到了<strong>正好一次</strong>的语义,考虑极端情况下，也可以做到至少一次。</p><h3 id="消息轮询"><a href="#消息轮询" class="headerlink" title="消息轮询"></a>消息轮询</h3><blockquote><p>业务系统触发事件之后，会将事件存储在数据库中，然后会有一个定时任务线程定时去轮询数据库获取消息，并使用kafka将消息发送到broker。</p></blockquote><h4 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h4><p>使用数据库的事务来保障业务服务接口产生的事件跟业务行为保持强一致性，而在定时发送消息时，也会使用数据库事务+kafka的事务，将消息发送出去。以下为发送消息的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def doPublishMessages(): Unit = &#123;</span><br><span class="line">    // 消息总条数计数器</span><br><span class="line">    val counter = new AtomicInteger(0)</span><br><span class="line">    // 批量处理, 每次从数据库取出消息的最大数量(window)</span><br><span class="line">    val window = 100</span><br><span class="line">    // 单轮处理的消息计数器, 用于控制循环退出.</span><br><span class="line">    val resultSetCounter = new AtomicInteger(window)</span><br><span class="line">    //当一次轮询拿到的消息达到了最大数时，会再次轮询数据库，以确保还有消息没有被发送</span><br><span class="line">    while (resultSetCounter.get() == window) &#123;</span><br><span class="line">      resultSetCounter.set(0)</span><br><span class="line">      //数据库事务开启</span><br><span class="line">      dataSource.withTransaction[Unit](conn =&gt; &#123;</span><br><span class="line">        //AAA</span><br><span class="line">        conn.eachRow[EventStore](sql&quot;SELECT * FROM common_event limit $&#123;window&#125; FOR UPDATE&quot;)(event =&gt; &#123;</span><br><span class="line">          conn.executeUpdate(sql&quot;DELETE FROM common_event WHERE id = $&#123;event.id&#125;&quot;)</span><br><span class="line">          //Kafka事务确保send失败会回滚并抛异常</span><br><span class="line">          producer.send(topic, event.id, event.eventBinary)</span><br><span class="line">          resultSetCounter.incrementAndGet()</span><br><span class="line">          counter.incrementAndGet()</span><br><span class="line">        //AAA</span><br><span class="line">           </span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面AAA块的代码中，我们将消息获取和kafka生产者发送消息放到了一个事务里，首先获取到消息，然后删除当前消息，再将消息发送到kafka上，保障消息刚好一次的发送。<br/></p><p>如果这时候出现异常(kafka发送数据异常或者删除数据库记录异常)，事务就会回滚，消息没有被真正删除，下一次轮询会再次执行这个过程。不考虑极端的情况下，这样的做法可以保证正好一次的消息发送。<br/></p><p>考虑极端情况，即消息的删除和kafka发送都成功了，而在事务提交那行代码时，出现异常。这时候，数据库会回滚，但是消息已经被发送到了kafka上，因此这里还是会出现消息的重复发送，但是做到了至少一次, 而且这种情况是极其极端的。</p><h3 id="生产端总结"><a href="#生产端总结" class="headerlink" title="生产端总结"></a>生产端总结</h3><p>我们已经在不考虑极端的情况下（服务器宕机）做到了正好一次，考虑极端的情况下，做到了至少一次。<br/></p><p>然而，极端情况还是有可能会出现，因此最好的解决方案是，我们还会在事件消息上面标记一个事件唯一ID，以支持用户在业务系统上消费消息的时候做幂等处理。<br/></p><p>如下是一个标准的业务事件的定义。（详情参考杨权文章）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishedSkuEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">   //事件唯一id</span></span></span><br><span class="line"><span class="params"><span class="class">   id : <span class="type">Long</span>, </span></span></span><br><span class="line"><span class="params"><span class="class">   //事件中携带的具体业务</span></span></span><br><span class="line"><span class="params"><span class="class">   skuIds : <span class="type">List</span>[<span class="type">Long</span>]</span></span></span><br><span class="line"><span class="params"><span class="class"> </span>)</span></span><br></pre></td></tr></table></figure><p>当然并不是所有的情况都需要这么强力的保障，比如对重复消息不是很敏感的情况，我们不需要发送事务消息或保证消息幂等性，只需要做到消息不会丢失即可。对于延迟敏感的，我们允许生产者指定它想要的耐用性水平。如生产者可以指定它获取需等待10毫秒量级上的响应。生产者也可以指定异步发送，或只等待leader（不需要副本的响应）有响应。</p><h2 id="Eventbus消息端（Consumer）"><a href="#Eventbus消息端（Consumer）" class="headerlink" title="Eventbus消息端（Consumer）"></a>Eventbus消息端（Consumer）</h2><blockquote><p>消费端分为领域内事件消费和跨领域事件消费，领域内由于在同一个事务内，强一致性，实现简单，我们这里不再赘述。现在，我们来分析下如何做到跨领域消息订阅和接收。</p></blockquote><h3 id="消息的编解码"><a href="#消息的编解码" class="headerlink" title="消息的编解码"></a>消息的编解码</h3><p>前文没有提到的一点，我们将事件定义为thrift结构体，并将其序列化为字节流之后持久化到数据库中，kafka发送的时候, 消息内容是序列化之后的二进制byte数组，消费端在接收到消息时，需要进行反序列化和解码后，才能得到消息对象。因此我们设计的api如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@KafkaConsumer(groupId = &quot;TEST01&quot;, topic =&quot;GOODS&quot;)</span><br><span class="line">public class EventConsumer &#123;</span><br><span class="line">   //定义消息的解码器</span><br><span class="line">    @KafkaListener(serializer = GoodsCreatedEventSerializer.class)</span><br><span class="line">    public void onGoodsCreatedEvent(GoodsCreatedEvent event) &#123;</span><br><span class="line">        // dosomething</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @KafkaListener(serializer = GoodsRegisteredEventSerializer.class)</span><br><span class="line">    public void onGoodsRegisteredEvent(GoodsRegisteredEvent event) &#123;</span><br><span class="line">        // dosomething</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@KafkaConsumer(groupId = &quot;TEST01&quot;, topic =&quot;SUPPLIER&quot;)</span><br><span class="line">public class EventConsumer &#123;</span><br><span class="line">   </span><br><span class="line">    @KafkaListener(serializer = SupplierCreatedEventSerializer.class)</span><br><span class="line">    public void onSupplierCreatedEvent(SupplierCreatedEvent event) &#123;</span><br><span class="line">        // dosomething</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>@KafkaConsumer</code>标于监听类上，定义消费者组和关心的topic。<br/><br><code>@KafkaListener</code>标于监听方法上,定义该方法监听的消息类型所需要的<strong>序列化器的class</strong>。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>业务系统需要把如上两个消息监听类交给Spring进行管理。</li><li>在启动容器时，eventbus类库里的<code>MsgAnnotationBeanPostProcessor</code>会对spring管理的bean进行扫描，如果发现有bean类上面有<code>@KafkaConsumer</code>注解时，就会将进一步判断该类下面是否有标有<code>@KafkaListener</code>的方法，代码如下（只显示主要逻辑）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化及依赖注入完成后、在任何初始化代码（比如配置文件中的init-method）调用之后调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = AopUtils.getTargetClass(bean);</span><br><span class="line">    <span class="comment">//获取类上是否有注解 @KafkaConsumer</span></span><br><span class="line">    Optional&lt;KafkaConsumer&gt; kafkaConsumer = findListenerAnnotations(targetClass);</span><br><span class="line">    <span class="comment">//类上是否有注解</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasKafkaConsumer</span> <span class="operator">=</span> kafkaConsumer.isPresent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasKafkaConsumer) &#123;</span><br><span class="line">        <span class="comment">//方法列表 ，查找方法上标有 @KafkaListener 的注解</span></span><br><span class="line">        Map&lt;Method, Set&lt;KafkaListener&gt;&gt; annotatedMethods = MethodIntrospector.selectMethods(targetClass,</span><br><span class="line">            (MethodIntrospector.MetadataLookup&lt;Set&lt;KafkaListener&gt;&gt;) method -&gt; &#123;</span><br><span class="line">                Set&lt;KafkaListener&gt; listenerMethods = findListenerAnnotations(method);</span><br><span class="line">                <span class="keyword">return</span> (!listenerMethods.isEmpty() ? listenerMethods : <span class="literal">null</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">if</span> (annotatedMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// throw Exception</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!annotatedMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// Non-empty set of methods</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Method, Set&lt;KafkaListener&gt;&gt; entry : annotatedMethods.entrySet()) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                <span class="keyword">for</span> (KafkaListener listener : entry.getValue()) &#123;</span><br><span class="line">                    <span class="comment">// process annotation information</span></span><br><span class="line">                    processKafkaListener(kafkaConsumer.get(), listener, method, bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">&quot;there are &#123;&#125; methods have @KafkaListener on This bean &quot;</span>, binlogMethods.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger.info(<span class="string">&quot;No @KafkaConsumer annotations found on bean type: &quot;</span> + bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果当前bean有<code>@KafkaConsumer</code>注解和<code>@KafkaListener</code>注解，就会创建当前<code>consumer</code>上下文，保存该类的<code>groupId,topic,serializer</code>等信息，并将这些信息注册到<code>KafkaListenerRegistrar</code>上面，KafkaListenerRegistrar会以groupId和topic联合作为key，并创建一个<code>kafkaConsumer</code>实例，放入一个实例列表中，相同的groupId和topic会使用同一个kafkaConsumer实例。代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaListenerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">//kafkaConsumer实例列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, MsgKafkaConsumer&gt; EVENT_CONSUMERS = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册业务consumer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerEndpoint</span><span class="params">(ConsumerEndpoint endpoint)</span> &#123;</span><br><span class="line">        Assert.notNull(endpoint, <span class="string">&quot;Endpoint must be set&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            addConsumer(endpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加consumer到列表，根据key判断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConsumer</span><span class="params">(ConsumerEndpoint endpoint)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupId</span> <span class="operator">=</span> endpoint.getGroupId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> endpoint.getTopic();</span><br><span class="line">        <span class="type">String</span> <span class="variable">kafkaHost</span> <span class="operator">=</span> endpoint.getKafkaHost();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 默认 group id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> endpoint.getBean().getClass().getName();</span><br><span class="line">            groupId = <span class="string">&quot;&quot;</span>.equals(groupId) ? className : groupId;</span><br><span class="line">            <span class="type">String</span> <span class="variable">consumerKey</span> <span class="operator">=</span> groupId + <span class="string">&quot;:&quot;</span> +   topic;</span><br><span class="line">            <span class="comment">//判断key</span></span><br><span class="line">            <span class="keyword">if</span> (EVENT_CONSUMERS.containsKey(consumerKey)) &#123;</span><br><span class="line">                EVENT_CONSUMERS.get(consumerKey).addConsumer(endpoint);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">MsgKafkaConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MsgKafkaConsumer</span>(kafkaHost, groupId, topic);</span><br><span class="line">                consumer.addConsumer(endpoint);</span><br><span class="line">                EVENT_CONSUMERS.put(consumerKey, consumer);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当所有bean被扫描完后，会调用此方法，启动kafkaConsumer实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;ready to start consumer ,event consumer size &#123;&#125;, binlog consumer size &#123;&#125;&quot;</span>, EVENT_CONSUMERS.size(), BINLOG_CONSUMERS.size());</span><br><span class="line"></span><br><span class="line">        EVENT_CONSUMERS.values().forEach(Thread::start);</span><br><span class="line"></span><br><span class="line">        BINLOG_CONSUMERS.values().forEach(Thread::start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面代码中，MsgKafkaConsumer处理消息接收和解码，并将解码后生产的具体事件内容作为参数，通过反射调用关注了该topic的方法，主要逻辑如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> public void run() &#123;</span><br><span class="line">        logger.info(&quot;[KafkaConsumer][&#123;&#125;][run] &quot;, this.groupId + &quot;:&quot; + this.topic);</span><br><span class="line">        this.consumer.subscribe(Arrays.asList(this.topic));</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ConsumerRecords&lt;Long, byte[]&gt; records = consumer.poll(100);</span><br><span class="line">                for (ConsumerRecord&lt;Long, byte[]&gt; record : records) &#123;</span><br><span class="line">                    logger.info(&quot;receive message,ready to process, topic: &#123;&#125; ,partition: &#123;&#125; ,offset: &#123;&#125;&quot;,</span><br><span class="line">                            record.topic(), record.partition(), record.offset());</span><br><span class="line"></span><br><span class="line">                    for (ConsumerEndpoint consumer : bizConsumers) &#123;</span><br><span class="line">                        dealMessage(consumer, record.value());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">consumer.commitSync();</span><br><span class="line">                &#125; catch (CommitFailedException e) &#123;</span><br><span class="line">                    logger.error(&quot;commit failed&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;[KafkaConsumer][&#123;&#125;][run] &quot; + e.getMessage(), groupId + &quot;:&quot; + topic, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 收到消息后具体处理</span><br><span class="line">    protected void dealMessage(ConsumerEndpoint consumer, byte[] message) &#123;</span><br><span class="line">        logger.info(&quot;Iterator and process biz message groupId: &#123;&#125;, topic: &#123;&#125;&quot;, groupId, topic);</span><br><span class="line"></span><br><span class="line">        KafkaMessageProcessor processor = new KafkaMessageProcessor();</span><br><span class="line">        String eventType = processor.getEventType(message);</span><br><span class="line"></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; parameterTypes = consumer.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        long count = parameterTypes.stream()</span><br><span class="line">                .filter(param -&gt; param.getName().equals(eventType))</span><br><span class="line">                .count();</span><br><span class="line"></span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            byte[] eventBinary = processor.getEventBinary();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Object event = processor.decodeMessage(eventBinary, consumer.getEventSerializer());</span><br><span class="line">                consumer.getMethod().invoke(consumer.getBean(), event);</span><br><span class="line">                logger.info(&quot;invoke message end ,bean: &#123;&#125;, method: &#123;&#125;&quot;, consumer.getBean(), consumer.getMethod());</span><br><span class="line">            &#125; catch (IllegalAccessException | InvocationTargetException | IllegalArgumentException e) &#123;</span><br><span class="line">                logger.error(&quot;参数不合法，当前方法虽然订阅此topic，但是不接收当前事件:&quot; + eventType, e);</span><br><span class="line">            &#125; catch (TException e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                logger.error(&quot;反序列化事件&quot; + eventType + &quot;出错&quot;);</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                logger.error(&quot;实例化事件&quot; + eventType + &quot;对应的编解码器失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.debug(&quot;方法 [ &#123;&#125; ] 不接收当前收到的消息类型 &#123;&#125; &quot;, consumer.getMethod(), eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>消费者设置为手动提交偏移量，在一次poll请求中，当消息成功消费后，会同步提交本次poll的消息偏移量。</li></ul><p>如果消息消费了，但是在未提交偏移量之前，消息是不会丢失的（未处理）。当消息消费后，准备提交偏移量是系统出错了，这时候会导致重复消费，因此也是至少一次的语义。所以这里交给业务系统时，还是需要业务去实现业务去重。</p><h3 id="消费端注意事项"><a href="#消费端注意事项" class="headerlink" title="消费端注意事项"></a>消费端注意事项</h3><p>我们在topic的基础上进行了更细粒化的区分，消息能够根据订阅者所感兴趣的事件类型进行选择性发送。<br/></p><p>即使两个订阅者方法都订阅了同一个topic，kafka消费者仍然会根据接收到的消息的类型和订阅者方法的所感兴趣的事件类型进行对比，如果当前接收到的事件与订阅事件一致，便会通过反射<strong>调用订阅者方法</strong>，并将收到的具体事件也传递过去，事件接收成功。</p><p>举个例子：</p><p>如果<code>kafkaConsumer</code>从broker接收到消息，解码之后发现事件类型为<code>UserCreated</code>,那他只会notify接收参数为<code>UserCreated</code>事件的方法，而不会去调用接收<code>UserRegisted</code>的订阅者方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DDD领域事件的消息总线分析就到这里，本文重点讲了跨领域时，通过kafka消息中间件如何做到消息的稳定发送和接收，不出现消息丢失，触发事件而未发送等情况。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;事件总线(EventBus)设计初衷是解耦系统模块，将系统中的各类业务操作抽象为事件模型。我们把产生事件的部分称之为事件的发送者(Publisher)，消费事件的部分称之为订阅者(Subcriber)。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="DDD" scheme="http://struy.cn/tags/DDD/"/>
    
    <category term="领域驱动设计" scheme="http://struy.cn/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Dapeng微服务" scheme="http://struy.cn/tags/Dapeng%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>领域事件及事件总线EventBus使用实践</title>
    <link href="http://struy.cn/2018/03/10/DDD-event-bus/"/>
    <id>http://struy.cn/2018/03/10/DDD-event-bus/</id>
    <published>2018-03-10T15:49:49.000Z</published>
    <updated>2023-04-25T00:32:10.345Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在过去的 30 多年，就已经有领域建模和设计的思潮；Eric Evans 将其定义为领域驱动设计（Domain-Driven Design，简称DDD）。领域模型是领域驱动的核心，而领域事件又作为领域模型中的重要模块，解决了开发者日常开发中的很多痛点，比如，代码耦合降低，拓展性增强。</p></blockquote><span id="more"></span><blockquote><p><a href="https://github.com/dapeng-soa">@大鹏开源</a>:别看我有点萌，我可以秒变大鹏😄</p></blockquote><p><img src="http://img.struy.cn/18-3-10/59987509.jpg"></p><h1 id="了解-DDD-与领域事件"><a href="#了解-DDD-与领域事件" class="headerlink" title="了解 DDD 与领域事件"></a>了解 DDD 与领域事件</h1><p>领域模型不是高大上的东西，所有的领域模型抽象都来自于具体的业务及业务的需求,而脱离业务需求的应用设计是没有任何价值的！</p><p>比如在Today的新零售电商架构中:门店、采购、订单、供应商、物流、商品、台账等等都是应用设计中的不同领域模型，必然还存在或多或少的子域模型。而对于技术人员来说，这些抽象出来的领域，就代表应用架构存在若干子系统。</p><p>系统与系统间，势必会存在某些关联。比如说A领域“发生某件事情”、“当什么产生变化的时候”、“如果什么状态变更”…，都将可能成为B领域所要关心的事件。</p><h1 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h1><ul><li><p>我们将发出事件通知的一方称为发送者 (Publisher) ,关心事件的一方称为订阅者 (Subscriber)。</p></li><li><p>关心一件事，便会收集这件事情相关的信息。而这些都将会转换为消息流，在订阅这件事情的领域间传播，一旦命中所要关心的事情，就由订阅者自行去处理接下来的事情。</p></li></ul><p><img src="http://img.struy.cn/18-3-12/24835978.jpg"><br>以上eventbus示意图大致流程是这样的：</p><ul><li>服务接口触发事件</li><li>eventbus 分发事件，如果存在领域内订阅者，直接分发到指定订阅者，再将事件消息存库定时发送至 kafka</li><li>如果不存在领域内订阅者，事件消息直接存库并定时发送 kafka</li><li>消息在发送成功以后会被清除，为了保证事务的一致性。建议事件db共享业务数据源</li><li>订阅者只需要订阅事件双方规约好的 topic 和事件类型就可以命中需要的事件消息</li></ul><h1 id="引入事件的依据"><a href="#引入事件的依据" class="headerlink" title="引入事件的依据"></a>引入事件的依据</h1><p>很多业务场景下，我们可能需要在某件事情完成后，根据业务完成状态来做业务路由。</p><blockquote><p>比如说商品领域的的变价审核业务，在商品变价审核通过之后，对应的商品价格也随之生效；价格的变动可能会引起采购，供应商，抑或者门店等领域作出响应的调整。</p></blockquote><p>而我们在代码中通常这样去描述与以上类似的业务：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> code = updateSkuPriceApproveStatus(skuId,status)</span><br><span class="line">code <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> =&gt; </span><br><span class="line">        <span class="comment">// successful, do A</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; </span><br><span class="line">        <span class="comment">// failure, do B</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; </span><br><span class="line">        <span class="comment">// do ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// If I am A</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span></span>:<span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// update Price</span></span><br><span class="line"><span class="comment">// do purchase work</span></span><br><span class="line"><span class="comment">// do supplier work</span></span><br><span class="line"><span class="comment">// do Store work</span></span><br><span class="line"><span class="comment">// or more</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，当主线业务遭遇某个状态时，需要第三方系统作出应对，我们在主线任务中加入了冗长的代码甚至引入别人的 api ，这使得我的单个业务变的臃肿、过度耦合、不易阅读。恰好领域事件帮助我们更加优雅的解决了这个问题！</p><blockquote><p>当引入事件后，do A 将变成了 send eventA</p></blockquote><h1 id="实践事件总线"><a href="#实践事件总线" class="headerlink" title="实践事件总线"></a>实践事件总线</h1><blockquote><p>在 today 中台服务团队的各领域实践中，已经开始投产 eventbus ，并且效果可观，三方系统的订阅对接相当便捷.那这样的事件机制该如何去使用？</p></blockquote><p>为了给第三方系统和本部门的业务开发人员提供一致性的开发体验，我们将事件总线从dapeng的框架中剥离出来, 单独提供了一套类库用于实现事件的发布以及订阅。</p><ul><li>事件总线eventBus的核心库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;com.today&quot; % &quot;event-bus_2.12&quot; % &quot;0.1-SNAPSHOT&quot;</span><br></pre></td></tr></table></figure><ul><li>事件内容及状态暂存支持</li><li>需要在业务数据库加入一张如下结构数据表,这将作为事件消息的暂存队列和事件发送状态存储表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `common_event` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>  COMMENT <span class="string">&#x27;事件id&#x27;</span>,</span><br><span class="line">  `event_type` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;事件类型&#x27;</span>,</span><br><span class="line">  `event_binary` <span class="type">blob</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;事件内容&#x27;</span>,</span><br><span class="line">  `updated_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">current_timestamp</span>() <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">current_timestamp</span>() COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><blockquote><p>这里以商品变价审核的状态变更为例，了解在开发中如何做事件发送与订阅.</p></blockquote><p>具体来说,就是四步:</p><ol><li>定义事件结构体</li><li>在服务接口方法中声明待发布的事件</li><li>通过EventBus发布事件</li><li>通过EventBus接收事件</li></ol><p>下面具体说明一下每个步骤:</p><h2 id="定义事件结构体"><a href="#定义事件结构体" class="headerlink" title="定义事件结构体"></a>定义事件结构体</h2><p>1.事件收发双方共同协定定义事件消息的内容, 一个领域的所有消息定义都在同一个独立的idl文件中. 这个idl文件应该放在发布者的API包中.</p><p>2.我们的事件对象需要定义一个事件 id (建议通过分布式取号服务来获取), 订阅者可以自己决定是否需要用这个事件 id 来做消息的幂等处理</p><p><code>==&gt; goods_events.thrift</code></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.today.api.goods.events</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 商品变价审核通过事件</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkuPriceUpdateApprovedEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事件id</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="number">1</span>:<span class="type">i64</span> id,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * sku_id</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="number">2</span>:<span class="type">i64</span> skuId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...more</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="声明待发布事件"><a href="#声明待发布事件" class="headerlink" title="声明待发布事件"></a>声明待发布事件</h2><ul><li>秉承代码及文档一致的理念，所有的服务都会在统一的文档站点进行开放展示，每个服务&#x2F;每个接口的描述,包括出入参都一目了然.</li><li>我们在服务接口方法里面声明需要发布的事件，这些事件清单将会在文档站点对应的服务方法中得到展示，减少服务开发人员的沟通成本，一看便知。</li></ul><p><code>== &gt;goods_service.thrift</code></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.today.api.goods.<span class="keyword">service</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用户服务</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GoodsAdminService</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"># 商品审核</span></span><br><span class="line"><span class="comment">## 事件</span></span><br><span class="line"><span class="comment">    1.SkuPriceUpdateApprovedEvent  商品变价审核通过事件</span></span><br><span class="line"><span class="comment">    2.SkuAttributeUpdateApprovedEvent  商品属性审核通过事件</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="type">i64</span> approveSku(<span class="comment">/** 审核请求实体**/</span><span class="number">1</span>:goods_request.ApproveSkuRequest request)</span><br><span class="line">    (events=<span class="string">&quot;com.today.api.goods.events.SkuPriceUpdateApprovedEvent,com.today.api.goods.events.SkuAttributeUpdateApprovedEvent&quot;</span>)</span><br><span class="line">    ...more</span><br><span class="line">&#125;(group=<span class="string">&quot;goods&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>在文档站点方法上效果如下：<br><img src="http://img.struy.cn/18-3-11/65554100.jpg"></li><li>显示独立的事件清单<br><img src="http://img.struy.cn/18-3-11/90371526.jpg"></li></ul><blockquote><p>注：如果想要了解更多有关文档站点的内容，请留意后期的 dapeng 文档站点专题</p></blockquote><ul><li>定义事件发布任务idl</li></ul><p><code>==&gt; goods_event_task.thrift</code></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.today.api.goods.<span class="keyword">service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 商品事件发布任务</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GoodsScheduledService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"># 事件发布</span></span><br><span class="line"><span class="comment">## 注意事项</span></span><br><span class="line"><span class="comment">    1.商品服务的事件发布任务</span></span><br><span class="line"><span class="comment">    2.不需在文档站点测试</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="keyword">void</span> publishEventMsg()</span><br><span class="line">&#125;(group=<span class="string">&quot;Scheduler&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>为发布任务服务提供以下实现模版</li></ul><p><code>==&gt; task/GoodsScheduledServiceImpl.scala</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ScheduledTask</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsScheduledServiceImpl</span> <span class="keyword">extends</span> <span class="title">GoodsScheduledService</span></span>&#123;</span><br><span class="line">  <span class="meta">@Resource</span>(name = <span class="string">&quot;messageTask&quot;</span>)</span><br><span class="line">  <span class="keyword">var</span> msgScheduler: <span class="type">MsgPublishTask</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ScheduledTaskCron</span>(cron = <span class="string">&quot;*/2 * * * * ?&quot;</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">publishEventMsg</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//EventBus已经处理了多节点同时触发的问题了</span></span><br><span class="line">    msgScheduler.doPublishMessages()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关键性的bean配置</p></li><li><p>所有的事件消息，最终都会发送到 kafka 的队列中，等待订阅者消费；所以每一个配置都将必不可少。<br><code>==&gt; spring/services.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--messageTask 事件发布任务bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageTask&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.today.eventbus.scheduler.MsgPublishTask&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;topic&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;KAFKA_TOPIC&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;kafkaHost&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;KAFKA_PRODUCER_HOST&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;tidPrefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;KAFKA_TID_PREFIX&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;tx_goods_dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>topic</code> kafka 消息 topic，领域区分(建议:<code>domain_version_event</code>)</p></li><li><p><code>kafkaHost</code> kafka 集群地址(如:127.0.0.1:9091,127.0.0.1:9092)</p></li><li><p><code>tidPrefix</code> kafka 事务 id 前缀，领域区分</p></li><li><p><code>dataSource</code> 使用业务的 dataSource</p></li><li><p>服务配置<br><code>==&gt; config_user_service.properties</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># event config</span><br><span class="line">KAFKA_TOPIC=goods_1.0.0_event</span><br><span class="line">KAFKA_PRODUCER_HOST=127.0.0.1:9092</span><br><span class="line">KAFKA_TID_PREFIX=goods_0.0.1</span><br></pre></td></tr></table></figure><p></p></li></ul><h2 id="通过EventBus发布事件"><a href="#通过EventBus发布事件" class="headerlink" title="通过EventBus发布事件"></a>通过EventBus发布事件</h2><ul><li>在做事件触发前,你需要实现 <code>AbstractEventBus</code> ，来做好自定义的本地监听分发</li></ul><p><code>==&gt; commons/EventBus.scala</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">EventBus</span> <span class="keyword">extends</span> <span class="title">AbstractEventBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事件在触发后，可能存在领域内的订阅者，以及跨领域的订阅者</span></span><br><span class="line"><span class="comment">    * 领域内的订阅者可以通过实现该方法进行分发</span></span><br><span class="line"><span class="comment">    * 同时,也会将事件发送到其他领域的事件消息订阅者</span></span><br><span class="line"><span class="comment">    * @param event</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dispatchEvent</span></span>(event: <span class="type">Any</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getInstance</span></span>: <span class="type">EventBus</span>.<span class="keyword">this</span>.<span class="keyword">type</span> = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>交由 spring 托管<br><code>==&gt; spring/services.xml</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;eventBus&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.today.service.commons.EventBus&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;tx_goods_dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>事件发布<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventBus</span>.fireEvent(<span class="type">RegisteredEvent</span>(event_id,user.id))</span><br></pre></td></tr></table></figure></li></ul><h2 id="通过EventBus接收事件"><a href="#通过EventBus接收事件" class="headerlink" title="通过EventBus接收事件"></a>通过EventBus接收事件</h2><ul><li>对于领域内事件订阅者</li></ul><p><code>EventBus</code> 的 <code>dispatchEvent</code> 方法提供领域内订阅者的事件分发，以便本地订阅者可以订阅到关注的事件消息。这些领域内的订阅者，只需要在 <code>dispatchEvent</code> 中模式匹配进行分发。是不是已经是相当的简洁呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dispatchEvent</span></span>(event: <span class="type">Any</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">     event <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e:<span class="type">SkuPriceUpdateApprovedEvent</span> =&gt;</span><br><span class="line">        <span class="comment">// do somthing </span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        <span class="type">LOGGER</span>.info(<span class="string">&quot; nothing &quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p>对于跨领域事件订阅者</p></li><li><p>依赖</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--if =&gt; maven project--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.today<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>event-bus_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--if =&gt; sbt project--&gt;</span> </span><br><span class="line">&quot;com.today&quot; % &quot;event-bus_2.12&quot; % &quot;0.1-SNAPSHOT&quot;</span><br></pre></td></tr></table></figure><ul><li>注解扫描支持配置：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;postProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.today.eventbus.MsgAnnotationBeanPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li>订阅事件消息<br>同一个领域的事件在同一个消费者类中处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="meta">@KafkaConsumer(groupId = &quot;goodsEventConsumer&quot;, topic = &quot;goods_1.0.0_event&quot;,kafkaHostKey = &quot;kafka.consumer.host&quot;)</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsEventsConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@KafkaListener(serializer = SkuAttributeUpdateApprovedEventSerializer.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeSkuAttributeUpdateApprovedEvent</span><span class="params">(SkuAttributeUpdateApprovedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(event.skuId);</span><br><span class="line">        <span class="comment">// do somthing</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//scala</span></span><br><span class="line">serializer = classOf[RegisteredEventSerializer]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><code>GoodsEventsConsumer</code> 也需要在 spring 上下文中托管。</li></ul><blockquote><p>@KafkaConsumer </p></blockquote><ul><li><code>groupId</code>：kafka Consumer groupId，领域区分</li><li><code>topic</code> ：kafka 消息 topic </li><li><code>kafkaHostKey</code>：  <ul><li>可自行配置的 kafka 地址，默认值为 <code>dapeng.kafka.consumer.host</code> ，可以自定义覆盖默认值</li><li>用户只要负责把这些配置放到 env 或者 properties 里面</li><li>如：<code>System.setProperty(&quot;kafka.consumer.host&quot;,&quot;127.0.0.1:9092&quot;);</code></li></ul></li></ul><blockquote><p>@KafkaListener </p></blockquote><ul><li>serializer 事件消息解码器，由事件发送方提供.</li></ul><h2 id="领域内消费事件与跨领域消费事件的不同"><a href="#领域内消费事件与跨领域消费事件的不同" class="headerlink" title="领域内消费事件与跨领域消费事件的不同"></a>领域内消费事件与跨领域消费事件的不同</h2><p>通过以上已经知道在事件中，存在领域内的订阅者消费事件消息，也可能存在跨领域的事件订阅者消费事件消息。下面将分析这两者的不同：</p><ul><li>领域内的事件订阅者，通常是<strong>不能脱离领域的存在，存在领域内强关系的，但又需要解耦！</strong> </li><li>而跨领域的事件消息订阅，通常<strong>只需保证最终一致性，他们相对事件发送方没有强依赖关系</strong>。<blockquote><p>需要注意的是：在 eventbus 中，领域内消费事件之后还是会将事件消息广播出去。因为不能保证不会有其他领域对发生的事件感兴趣！</p></blockquote></li></ul><blockquote><p>如商品领域的商品变价审核通过后，触发了审核通过事件：</p></blockquote><ul><li>事件触发后将使价格生效，这部分生效操作可以通过领域内的事件订阅进行解耦。</li><li>因为更新了商品价格，可能存在库存系统或者其他业务系统对商品数据敏感，可以通过跨领域事件发送-订阅，做商品的数据推送</li></ul><h2 id="附-binlog-kafka动态缓存更新支持"><a href="#附-binlog-kafka动态缓存更新支持" class="headerlink" title="附:binlog-kafka动态缓存更新支持"></a>附:binlog-kafka动态缓存更新支持</h2><blockquote><p>@BinlogListener</p></blockquote><ul><li>eventbus将订阅者 api 进行了有趣的拓展，加入binlog-kafka动态缓存更新支持</li><li>使用方法与事件的订阅者方法类似，唯一的不同就是你不再需要消息解码器！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BinlogListener</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binlogListener</span><span class="params">(List&lt;BinlogEvent&gt; events)</span>&#123;</span><br><span class="line">      <span class="comment">// do somthing</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，EventBus 的引入对于开发者而言，不论是事件的发送还是订阅，都是易用的，没有多余的配置。对于第三方系统的支持也做的非常优秀，希望在日常开发中能够更加灵活的运用。尽量减少不必要的耦合！并能经受实践考验！</p><ul><li>原文地址: <a href="http://struy.cn/2018/03/10/DDD-event-bus/">http://struy.cn/2018/03/10/DDD-event-bus/</a></li><li>同步简书地址: <a href="https://www.jianshu.com/p/88abce9326aa">https://www.jianshu.com/p/88abce9326aa</a></li></ul><blockquote><p>有关eventBus的具体实现细节，将由小伙伴 hz.lei 来进行剖析！</p></blockquote><ul><li>hz.lei: <a href="https://www.jianshu.com/p/f89741097113">DDD-事件总线实现架构原理分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在过去的 30 多年，就已经有领域建模和设计的思潮；Eric Evans 将其定义为领域驱动设计（Domain-Driven Design，简称DDD）。领域模型是领域驱动的核心，而领域事件又作为领域模型中的重要模块，解决了开发者日常开发中的很多痛点，比如，代码耦合降低，拓展性增强。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="DDD" scheme="http://struy.cn/tags/DDD/"/>
    
    <category term="领域驱动设计" scheme="http://struy.cn/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="EventBus" scheme="http://struy.cn/tags/EventBus/"/>
    
    <category term="Dapeng微服务" scheme="http://struy.cn/tags/Dapeng%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>scala函数的演变过程,函数式的优点</title>
    <link href="http://struy.cn/2018/01/06/scala-function-5w/"/>
    <id>http://struy.cn/2018/01/06/scala-function-5w/</id>
    <published>2018-01-06T14:05:50.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>scala中，带有函数式编程思想的代码很多，如何去理解才更加容易？</p></blockquote><span id="more"></span><p><img src="http://img.struy.cn/18-1-6/5222114.jpg"></p><ul><li>传统<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def plusOne(num:Int):Int = &#123;</span><br><span class="line">    num+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>改革过程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(Int)=&gt;Int // 函数的&quot;类型&quot;提取</span><br><span class="line"></span><br><span class="line">(num)=&gt;&#123;</span><br><span class="line">    num+1 // 函数的&quot;值&quot;提取</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(num)=&gt;num+1 </span><br></pre></td></tr></table></figure></li><li>结合改革成果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val plusOne:Int=&gt;Int=&#123;</span><br><span class="line">    (num)=&gt;num+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>还可以变<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val plusOne=(num:Int) =&gt; num+1</span><br></pre></td></tr></table></figure></li><li>函数的字面量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(num:Int) =&gt; num+1</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="何处使用"><a href="#何处使用" class="headerlink" title="何处使用"></a>何处使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">val nums=List[Int](1,2,3)</span><br><span class="line">@#</span><br><span class="line">map(f:Int =&gt; B)</span><br><span class="line">// 这是scala中map方法的定义</span><br><span class="line">// 这里指出map方法需要接受一个Int类型的值f，任意的表达式运算B</span><br><span class="line">// 回过头再把函数的的变革过程想一遍那它应该是怎样&quot;一类的函数&quot;</span><br><span class="line"></span><br><span class="line">//下面是我的理解</span><br><span class="line">(x:Int) =&gt; B // 此时B看作最后的运算结果得到的类型</span><br><span class="line"></span><br><span class="line">(x)=&gt;&#123;</span><br><span class="line">    B // 此时B看作是一个过程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val plusOne=(x:Int) =&gt; x+1</span><br><span class="line">val mString=(x:Int) =&gt; x.toString</span><br><span class="line"></span><br><span class="line">@A</span><br><span class="line">nums.map((x:Int) =&gt; x+1)</span><br><span class="line"></span><br><span class="line">@B</span><br><span class="line">nums.map(plusOne)</span><br><span class="line"></span><br><span class="line">@C</span><br><span class="line">nums.map(mString)</span><br></pre></td></tr></table></figure><ul><li>@A和@B达到了同样的效果</li><li>plusOne和mString是一类函数，可插拔(引用透明)</li><li>plusOne和mString都是从值&#x3D;&gt;值的过程，是一条线(纯函数)，这就涉及到函数的副作用</li></ul><h3 id="函数副作用-摘自维基"><a href="#函数副作用-摘自维基" class="headerlink" title="函数副作用(摘自维基)"></a>函数副作用(摘自维基)</h3><blockquote><p>函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p></blockquote><ul><li>纯函数<ul><li>输入输出数据流全是显式（Explicit）的 </li><li>函数与外界交换数据只有一个唯一渠道——参数和返回值</li><li>没有副作用的函数</li></ul></li><li>非纯函数<ul><li>函数通过隐式（Implicit）方式，从外界获取数据，或者向外部输出数据</li><li>比如，读取全局变量，修改全局变量</li></ul></li><li>引用透明<ul><li>引用透明（Referential Transparent）的概念与函数的副作用相关，且受其影响</li><li>如果程序中任意两处具有<strong>相同输入值的函数</strong>调用能够互相置换，而不影响程序的动作，那么该程序就具有引用透明性</li></ul></li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><ul><li>纯函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) &#123; </span><br><span class="line">   return x + 1 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>非纯函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 0 </span><br><span class="line">q(x) &#123; </span><br><span class="line">   b = a </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">p(x)&#123; </span><br><span class="line">    print“hello” </span><br><span class="line">&#125;</span><br><span class="line">// p(x)通过I/O API输出了一个字符串。p(x)是非纯函数。</span><br></pre></td></tr></table></figure></li></ul><h3 id="纯函数优点"><a href="#纯函数优点" class="headerlink" title="纯函数优点"></a>纯函数优点</h3><ul><li>无状态。线程安全。不需要线程同步。</li><li>纯函数相互调用组装起来的函数，还是纯函数。</li><li>应用程序或者运行环境（Runtime）可以对纯函数的运算结果进行缓存，运算加快速度。</li></ul><p>参考</p><p><a href="http://blog.csdn.net/bluishglc/article/details/45291533">http://blog.csdn.net/bluishglc/article/details/45291533</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;scala中，带有函数式编程思想的代码很多，如何去理解才更加容易？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Scala" scheme="http://struy.cn/tags/Scala/"/>
    
    <category term="函数式编程" scheme="http://struy.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Angular(4)中加载Arcgis for JavaScript地图</title>
    <link href="http://struy.cn/2017/09/16/Angular-load-ArcGis-for-JavaScript/"/>
    <id>http://struy.cn/2017/09/16/Angular-load-ArcGis-for-JavaScript/</id>
    <published>2017-09-16T06:40:36.000Z</published>
    <updated>2023-04-25T00:32:10.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>近期我司项目的需要，采用Angular(4)+SpringBoot前后端分离的架构。并且在需要在项目中实现Arcgis地图。  </p></blockquote><h2 id="寻"><a href="#寻" class="headerlink" title="寻"></a>寻</h2><p>像我这种菜鸡遇到这种没有干过的事情肯定是先问百度和谷歌,两个关键词敲下。几乎搜索的内容里很少有两个关键字共存的。但是我这慧眼识得好代码，于是发现了这: <a href="https://github.com/Esri/angular-esri-map">https://github.com/Esri/angular-esri-map</a></p><p>Esri是美国环境系统研究所公司,多年来，ESRI公司始终将GIS视为一门科学.也就是说这是官方实例呀。</p><span id="more"></span><p>这样就完了吗？不，事情总是没那么简单的。我以负八级的英文水平开始看这个项目的README,第一行。心都碎了[手动心碎]他是这样说的。</p><blockquote><p>A collection of directives to help you use Esri maps and services in your AngularJS v1.x applications.</p></blockquote><p>wtf?&#x3D;&#x3D;&gt;AngularJS v1.x applications，我的项目用的可是4.x，这不扯淡？</p><p>继续遨游在GayHub[手动滑稽]的代码海洋里。皇天不负有心人让我找到了他:<br><a href="https://github.com/tomwayson/angular2-esri-example">https://github.com/tomwayson/angular2-esri-example</a></p><p>在这里我尝试将他的项目clone到本地，的确可以跑起来，并且可以看到地图,但尝试获取核心代码但是在包下载的时候就出现了很多问题于是放弃了[真的是无限差包]。</p><h2 id="雾"><a href="#雾" class="headerlink" title="雾"></a>雾</h2><p>因为之前看到是2.x版本就机遇尝试便没有仔细阅读本项目的说明文档。回去看他的说明文档并把<code>Resources</code>节点下的东西都挨个看了一遍,发现了其中一项貌似很有用：</p><ul><li><a href="https://github.com/tomwayson/esri-angular-cli-example">Example of how to use the ArcGIS API for JavaScript in an angular-cli application</a></li><li>【译】如何在 Angular CLI 程序中使用ArcGIS API for JavaScript的示例</li></ul><p>于是开始阅读这个示例的说明文档，他在文中提到:</p><blockquote><p>This repository is an example of one way to use the ArcGIS API for JavaScript in an application generated with angular-cli.<br>此存储库是在使用angular-cli生成的应用程序中使用ArcGIS API for JavaScript的一种方法的示例</p></blockquote><p>还有一句:</p><blockquote><p>Adding the ArcGIS API to your own angular-cli application<br>将ArcGIS API添加到您自己的Angular-cli应用程序</p></blockquote><blockquote><p>Rather than clone this repository, you should create your own application with the angular-cli and then follow the instructions below to add the above libraries:<br>而不是克隆此存储库，您应该使用angular-cli创建自己的应用程序，然后按照以下说明添加以上库：</p></blockquote><p>下面的是说明：</p><ul><li><a href="https://github.com/tomwayson/angular-esri-loader/blob/master/README.md#in-an-angular-cli-application">angular2-esri-loader</a> - a low level service needed to load and use ArcGIS modules (v3.x or v4.x) in your Angular applications<ul><li>在Angular应用程序中加载和使用ArcGIS模块（v3.x或v4.x）所需的低级服务</li></ul></li><li><a href="https://github.com/TheKeithStewart/angular-esri-components#setup">angular-esri-components</a> - a set of reusable components for use with v4.x (only) of the ArcGIS API<ul><li>一组（仅）可用于ArcGIS API v4.x的可重用组件</li></ul></li></ul><hr><p>上面的意思已经很清楚。这个项目不建议clone，而是使用angular2-esri-loader 来加载ArcGIS模块，angular-esri-components组件是只能在Arcgis4.x版本中使用的。</p><p>当点开<a href="https://github.com/tomwayson/angular-esri-loader/blob/master/README.md#in-an-angular-cli-application">angular2-esri-loader</a>这个模块的时候，会很清楚的看到如何安装这个Angular的gis加载库，并且写了示例程序。对于angular有一定的了解的话，这些代码或许就能很清晰的表达出它在做什么。</p><p>示例的代码就不列出，可以到github上阅读。大体流程是：</p><ul><li>npm安装<a href="https://github.com/tomwayson/angular-esri-loader">angular-esri-loader</a>,Angular版本不同则安装的命令和库也会存在差异</li><li>EsriLoaderModule模块加载到程序中</li><li>使用EsriLoaderService组件加载地图</li><li>文档中加载的是基础图层，但一般开发时会加载缓存地图服务或者其他类型地图服务。这将在我的的示例项目中看到</li></ul><p>项目示例:<br><a href="https://git.oschina.net/StruggleYang/ngGisDemo">https://git.oschina.net/StruggleYang/ngGisDemo</a></p><p>项目效果:  </p><p><img src="http://img.struy.cn/17-9-16/48529141.jpg"></p><h2 id="差"><a href="#差" class="headerlink" title="差"></a>差</h2><p>你如果看过Arcgis for JavaScript的代码。那么JavaScript代码，如何转换为Angular(TypeScript)的代码，这里我也没有做过多的了解，只是照葫芦画瓢写的一些:  </p><p>这里推荐去看一下阮一峰的:<a href="http://es6.ruanyifeng.com/">ES6标准入门</a>可以提供一些参考  </p><p>下面将做出原生的Arcgis for JavaScript代码和Angular中的书写对比。</p><p>变量声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有可能你需要在地图初始化前首先声明变量，以便你在任何地方都是可用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map; <span class="comment">// js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">map</span>: any; <span class="comment">// ts</span></span><br></pre></td></tr></table></figure><p>地图的模块加载，Arcgis的api是基于dojo框架的，如下:</p><ul><li>JavaScript中加载地图模块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;esri/map&quot;</span>, <span class="string">&quot;dojo/domReady!&quot;</span>], <span class="keyword">function</span>(<span class="params"><span class="built_in">Map</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="string">&quot;map&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">center</span>: [-<span class="number">118</span>, <span class="number">34.5</span>],</span><br><span class="line">    <span class="attr">zoom</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">basemap</span>: <span class="string">&quot;topo&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Angular中加载地图(基于angular-esri-loader加载器)<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里代码并不全，具体请查看上面的示例项目</span></span><br><span class="line">.. 省略导入</span><br><span class="line"></span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;map&#x27;</span>) <span class="attr">mapEl</span>: <span class="title class_">ElementRef</span>;</span><br><span class="line"> <span class="attr">map</span>: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">esriLoader</span>.<span class="title function_">load</span>(&#123;</span><br><span class="line">    <span class="comment">// 在js中是不管这个url的，因为它在html中已经引入对应的版本</span></span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;//js.arcgis.com/3.18/&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">esriLoader</span>.<span class="title function_">loadModules</span>([<span class="string">&#x27;esri/map&#x27;</span>]).<span class="title function_">then</span>(<span class="function">(<span class="params">[<span class="built_in">Map</span>]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="variable language_">this</span>.<span class="property">mapEl</span>.<span class="property">nativeElement</span>, &#123;</span><br><span class="line">          <span class="attr">center</span>: [-<span class="number">118</span>, <span class="number">34.5</span>],</span><br><span class="line">          <span class="attr">zoom</span>: <span class="number">8</span>,</span><br><span class="line">          <span class="attr">basemap</span>: <span class="string">&#x27;topo&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>dojo事件添加:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// dojo点击事件添加 by JavaScript</span></span><br><span class="line">dojo.<span class="title function_">connect</span>(map, <span class="string">&#x27;onClick&#x27;</span>, <span class="keyword">function</span>(<span class="params">evt</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> emp = evt.<span class="property">mapPoint</span>;</span><br><span class="line">    <span class="keyword">var</span> cur_wkid = emp.<span class="property">spatialReference</span>.<span class="property">wkid</span>; </span><br><span class="line">    ... more code</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// dojo点击事件添加 by Angular</span></span><br><span class="line">dojo.<span class="title function_">connect</span>(<span class="variable language_">this</span>.<span class="property">map</span>, <span class="string">&#x27;onClick&#x27;</span>, <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> emp = evt.<span class="property">mapPoint</span>;</span><br><span class="line">    <span class="keyword">const</span> cur_wkid = emp.<span class="property">spatialReference</span>.<span class="property">wkid</span>; </span><br><span class="line">    ... more code</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里实际上就是一个箭头函数的区别还有变量的声明区别。</p><h2 id="花"><a href="#花" class="headerlink" title="花"></a>花</h2><p>这就结束了？</p><p>不不不，远远还不只这些。不论是Angular还是Arcgis,很多东西都没有做过多的了解和深入。不知道那行代码存在隐患。所以革命尚未成功，还得加倍学习和实践巩固。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;近期我司项目的需要，采用Angular(4)+SpringBoot前后端分离的架构。并且在需要在项目中实现Arcgis地图。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;寻&quot;&gt;&lt;a href=&quot;#寻&quot; class=&quot;headerlink&quot; title=&quot;寻&quot;&gt;&lt;/a&gt;寻&lt;/h2&gt;&lt;p&gt;像我这种菜鸡遇到这种没有干过的事情肯定是先问百度和谷歌,两个关键词敲下。几乎搜索的内容里很少有两个关键字共存的。但是我这慧眼识得好代码，于是发现了这: &lt;a href=&quot;https://github.com/Esri/angular-esri-map&quot;&gt;https://github.com/Esri/angular-esri-map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Esri是美国环境系统研究所公司,多年来，ESRI公司始终将GIS视为一门科学.也就是说这是官方实例呀。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Angular" scheme="http://struy.cn/tags/Angular/"/>
    
    <category term="WebGis" scheme="http://struy.cn/tags/WebGis/"/>
    
  </entry>
  
  <entry>
    <title>一个命令,解决hexo多机更新操作</title>
    <link href="http://struy.cn/2017/09/09/hexo-all-update-by-shell/"/>
    <id>http://struy.cn/2017/09/09/hexo-all-update-by-shell/</id>
    <published>2017-09-08T23:44:46.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为本博客是基于Hexo+GitHub-Pages,所以在<code>hexo -d</code>后生成的静态文件都存放于github，所以这是不用担心的。本地的hexo博客的源文件内存放着大量的文章markdown文件,所以问题来了。如果换电脑或者硬件损坏，或者有在其他机器更新文章的需求。就需要做一件事情就是将源文件，也就是本地hexo博客源文件的根目录整个备份。</p><span id="more"></span><p>在那么现在就必须做一些前置操作，就是把你的hexo博客源文件备份到GitHub或者其他代码托管平台，这里的操作就不写出来了，可以参考<a href="http://img.struy.cn/2017/09/02/git%E5%88%9D%E8%AF%86/">罪恶的起源，git初识</a>里的如何将代码提交到远程仓库。</p><blockquote><p>也可以使用开源中国的<a href="https://git.oschina.net/">码云</a>,我就是用的码云[手动滑稽]，操作都是一样的。</p></blockquote><blockquote><p>清除hexo的<code>public</code>目录&#x3D;&gt;重新生成静态文件&#x3D;&gt;更新github pages的文章内容&#x3D;&gt;拉取其他机器的提交&#x3D;&gt;将所有的文章Markdown源文件改动add到本地暂存&#x3D;&gt;提交&#x3D;&gt;push源文件到另一个备份仓库</p></blockquote><p>那么这个命令如何实现，在上一篇文章的额基础上，我对三个命令做出了拓展，使它有一些基本的功能，比如<code>help</code>,防止自己也忘了这个命令干嘛的。加入了只是本地预览博客的指令<code>-s</code>。已经一些友好的提示,让你知道它都做了什么。那么来看看这个命令的脚本长什么样吧！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  by StruggleYang</span></span><br><span class="line"><span class="comment">#  this is update hexo page or post and backup source</span></span><br><span class="line">this=<span class="variable">$0</span></span><br><span class="line">message=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">help</span>=<span class="string">&quot;help&quot;</span></span><br><span class="line">server=<span class="string">&quot;-s&quot;</span></span><br><span class="line"><span class="comment"># Always pull the latest</span></span><br><span class="line">git pull origin master &amp;&amp;</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$message</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$message</span>&quot;</span> = <span class="string">&quot;<span class="variable">$help</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$this</span>&gt;&gt;help : &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;There is only one parameter: commit-message  or -s [locahost server preview Blog] &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;After the command, add updates to this blog and submit it to the backup repository!&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$message</span>&quot;</span> = <span class="string">&quot;<span class="variable">$server</span>&quot;</span> ]  </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$this</span> ====hexo &gt;&gt; clean &gt;&gt; generate &gt;&gt; server &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==========hexo clean  ...===========&quot;</span> &amp;&amp;</span><br><span class="line">hexo clean &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==========hexo generate ...=========&quot;</span> &amp;&amp;</span><br><span class="line">hexo g &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==========hexo server ...=========&quot;</span> &amp;&amp;</span><br><span class="line">hexo s</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$this</span> ==== [hexo] &gt;&gt; clean &gt;&gt; generate &gt;&gt; deploy ==|~|== [git] &gt;&gt; add &gt;&gt; commit &gt;&gt; push &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==========hexo clean  ...===========&quot;</span> &amp;&amp;</span><br><span class="line">hexo clean &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==========hexo generate ...=========&quot;</span> &amp;&amp;</span><br><span class="line">hexo g &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==========hexo deploy ...===========&quot;</span> &amp;&amp;</span><br><span class="line">hexo d &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==========backup hexo source to git.osc ...=========&quot;</span> &amp;&amp;</span><br><span class="line">git add -A . &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==========commit message: [ <span class="variable">$message</span> ]=========&quot;</span> &amp;&amp;</span><br><span class="line">git commit -m <span class="string">&quot;<span class="variable">$message</span>&quot;</span> &amp;&amp; git push origin master</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$this</span>&gt;&gt;help : &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;There is only one parameter: commit-message  or help or -s [locahost server preview Blog]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;After the command, add updates to this blog and submit it to the backup repository!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; ==========Over===========&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设已经将此脚本命名为<code>up.sh </code>  </p><p>当我输入 <code>sh up.sh</code>时：  </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sh up.sh</span><br><span class="line">        up.sh&gt;&gt;<span class="built_in">help</span> :</span><br><span class="line">        There is only one parameter: commit-message  or <span class="built_in">help</span> or -s [locahost server preview Blog]</span><br><span class="line">        After the command, add updates to this blog and submit it to the backup repository!</span><br><span class="line"> ==========Over===========</span><br></pre></td></tr></table></figure><p>当我输入<code>sh up.sh help</code>提示和以上一样，所以我是希望能够在每次更新和提交时，能够足够便捷，并且能够提示我填写commit的desc<br>还有一个指令是<code>-s</code> ，这个指令的作用显而易见只是将hexo的page重新生成并且能够本地预览。获取并不想提交更新，或者只是调试！</p><p>当我真正的需要更新文章或者博客的布局，并且备份元数据！<br>只需要这样写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh up.sh &quot;this is commit message test&quot;</span><br></pre></td></tr></table></figure><p>运行如下:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">hexo</span> (<span class="title">master</span>)                                                                                  </span></span><br><span class="line"><span class="function">λ <span class="title">sh</span> <span class="title">up.sh</span> &quot;<span class="title">this</span> <span class="title">is</span> <span class="title">commit</span> <span class="title">message</span> <span class="title">test</span>&quot;                                                                            </span></span><br><span class="line"><span class="function">        <span class="title">up.sh</span> ==== [<span class="title">hexo</span>] &gt;&gt; <span class="title">clean</span> &gt;&gt; <span class="title">generate</span> &gt;&gt; <span class="title">deploy</span> ==|~|== [<span class="title">git</span>] &gt;&gt; <span class="title">add</span> &gt;&gt; <span class="title">commit</span> &gt;&gt; <span class="title">push</span>                        </span></span><br><span class="line"><span class="function">==========<span class="title">hexo</span> <span class="title">clean</span>  ...===========                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Deleted</span> <span class="title">database</span>.                                                                                                </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Deleted</span> <span class="title">public</span> <span class="title">folder</span>.                                                                                           </span></span><br><span class="line"><span class="function">==========<span class="title">hexo</span> <span class="title">generate</span> ...=========                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Start</span> <span class="title">processing</span>                                                                                                 </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Files</span> <span class="title">loaded</span> <span class="title">in</span> 1.4 <span class="title">s</span>                                                                                            </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Generated</span>: <span class="title">content.json</span>                                                                                          </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Generated</span>: <span class="title">index.html</span>                                                                                            </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Generated</span>: <span class="title">tools</span>/<span class="title">index.html</span>                                                                                      </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Generated</span>: <span class="title">soul</span>/<span class="title">index.html</span> </span></span><br><span class="line"><span class="function">........省略部分                                                                                  </span></span><br><span class="line"><span class="function">==========<span class="title">hexo</span> <span class="title">deploy</span> ...===========                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Deploying</span>: <span class="title">git</span>                                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Clearing</span> .<span class="title">deploy_git</span> <span class="title">folder</span>...                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Copying</span> <span class="title">files</span> <span class="title">from</span> <span class="title">public</span> <span class="title">folder</span>...                                                                              </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Copying</span> <span class="title">files</span> <span class="title">from</span> <span class="title">extend</span> <span class="title">dirs</span>...     </span></span><br><span class="line"><span class="function">........省略部分                                                                             </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Deploy</span> <span class="title">done</span>: <span class="title">git</span>                                                                                                 </span></span><br><span class="line"><span class="function">==========<span class="title">backup</span> <span class="title">hexo</span> <span class="title">source</span> <span class="title">to</span> <span class="title">git.osc</span> ...=========                                                                   </span></span><br><span class="line"><span class="function"><span class="title">warning</span>: <span class="title">LF</span> <span class="title">will</span> <span class="title">be</span> <span class="title">replaced</span> <span class="title">by</span> <span class="title">CRLF</span> <span class="title">in</span> <span class="title">source</span>/<span class="title">_posts</span>/<span class="title">hexo</span>-<span class="title">all</span>-<span class="title">update</span>-<span class="title">by</span>-<span class="title">shell.md</span>.                                     </span></span><br><span class="line"><span class="function"><span class="title">The</span> <span class="title">file</span> <span class="title">will</span> <span class="title">have</span> <span class="title">its</span> <span class="title">original</span> <span class="title">line</span> <span class="title">endings</span> <span class="title">in</span> <span class="title">your</span> <span class="title">working</span> <span class="title">directory</span>.                                                </span></span><br><span class="line"><span class="function">==========<span class="title">commit</span> <span class="title">message</span>: [ <span class="title">this</span> <span class="title">is</span> <span class="title">commit</span> <span class="title">message</span> <span class="title">test</span> ]=========                                                     </span></span><br><span class="line"><span class="function">3 <span class="title">files</span> <span class="title">changed</span>, 34 <span class="title">insertions</span>(+), 2 <span class="title">deletions</span>(-)</span></span><br><span class="line"><span class="function"><span class="title">Counting</span> <span class="title">objects</span>: 27, <span class="title">done</span>.</span></span><br><span class="line"><span class="function"><span class="title">Delta</span> <span class="title">compression</span> <span class="title">using</span> <span class="title">up</span> <span class="title">to</span> 4 <span class="title">threads</span>.</span></span><br><span class="line"><span class="function"><span class="title">Compressing</span> <span class="title">objects</span>: 100% (27/27), <span class="title">done</span>.</span></span><br><span class="line"><span class="function"><span class="title">Writing</span> <span class="title">objects</span>: 100% (27/27), 14.86 <span class="title">KiB</span> | 0 <span class="title">bytes</span>/<span class="title">s</span>, <span class="title">done</span>.</span></span><br><span class="line"><span class="function"><span class="title">Total</span> 27 (<span class="title">delta</span> 14), <span class="title">reused</span> 0 (<span class="title">delta</span> 0)</span></span><br><span class="line"><span class="function"><span class="title">To</span> <span class="title">https</span>://<span class="title">git.oschina.net</span>/<span class="title">StruggleYang</span>/<span class="title">hexo.git</span></span></span><br><span class="line"><span class="function">   <span class="title">d9838c0</span>..50<span class="title">bb11d</span>  <span class="title">master</span> -&gt; <span class="title">master</span>                          </span></span><br><span class="line"><span class="function"> ==========<span class="title">Over</span>===========                                                                       </span></span><br></pre></td></tr></table></figure><h2 id="如何多机更新"><a href="#如何多机更新" class="headerlink" title="如何多机更新"></a>如何多机更新</h2><p>等你换了电脑或者公司的电脑来更新的的时候。前提是这台电脑是需要有node.js和npm以及hexo环境的。那只需要将备份的元数据clone到你想要的位置。  </p><p>执行:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><blockquote><p>然后更新文章，继续使用这个脚本来使得hexo变得更为轻松！</p></blockquote><blockquote><p>事实证明，这样的方式暂时是没有什么问题的。并且非常的方便！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;因为本博客是基于Hexo+GitHub-Pages,所以在&lt;code&gt;hexo -d&lt;/code&gt;后生成的静态文件都存放于github，所以这是不用担心的。本地的hexo博客的源文件内存放着大量的文章markdown文件,所以问题来了。如果换电脑或者硬件损坏，或者有在其他机器更新文章的需求。就需要做一件事情就是将源文件，也就是本地hexo博客源文件的根目录整个备份。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="http://struy.cn/tags/Hexo/"/>
    
    <category term="Shell" scheme="http://struy.cn/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>罪恶的起源，git初识</title>
    <link href="http://struy.cn/2017/09/02/git-0/"/>
    <id>http://struy.cn/2017/09/02/git-0/</id>
    <published>2017-09-02T01:46:00.000Z</published>
    <updated>2023-04-25T00:32:10.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git和svn的区别"><a href="#git和svn的区别" class="headerlink" title="git和svn的区别"></a>git和svn的区别</h2><ul><li>SVN、cvs集中式的版本控制系统  </li><li>Git是分布式版本控制系统</li></ul><h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><p>Linux 尝试输入git可查看是否安装，如果未安装按照提示安装</p><p>windows直接官网下桌面版</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><span id="more"></span>  <p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址</p><p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本仓库"><a href="#创建版本仓库" class="headerlink" title="创建版本仓库"></a>创建版本仓库</h2><blockquote><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。  </p></blockquote><p>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><p>pwd命令用于显示当前目录</p><p><strong>Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</strong>  </p><p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏</p><p>如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><p>在当前目录中添加任意文件：readme.txt(示例而已)</p><p>将文件添加到仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>将文件提交仓库中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) cb926e7] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><h2 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h2><p>修改了文件<code>git status</code>查看状态    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#    modified:   readme.txt</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p><p><code>git diff</code>查看具体修改的内容差异</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p><code>git log</code>命令显示从最近到最远的提交日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit ea34578d5496d7dd233c827ed32a8cd576c5ee85</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 14:53:12 2013 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit cb926e7ea50ad11b8f9e909c05226233bf755030</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 19 17:51:55 2013 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log --pretty=oneline</code>显示简略信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">3628164fb26d48395383f8f31179f24e0882e1e0 append GPL</span><br><span class="line">ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed</span><br><span class="line">cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file</span><br></pre></td></tr></table></figure><blockquote><p>类似3628164…882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p></blockquote><p>回退上一个版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>回退上一个的上一个版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^^</span><br></pre></td></tr></table></figure><p>版本多了就</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~100</span><br></pre></td></tr></table></figure><p>通过commit id回退版本或回到最新版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3628164</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向你回退的版本</p><blockquote><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p></blockquote><p>Git提供了一个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>用来记录你的每一次命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>这样可以找到某个版本的commit id了</p><h2 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h2><p>操作git的目录就是工作区</p><p>版本库：<br>在git init时，会在当前工作区目录下生成.git目录。这不属于工作区的，而属于Git版本库</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" alt="image"></p><p>把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改： </p><p>一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>从版本库中删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm file</span><br></pre></td></tr></table></figure><p>提交</p><h2 id="远程仓库（github）"><a href="#远程仓库（github）" class="headerlink" title="远程仓库（github）"></a>远程仓库（github）</h2><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。<br>如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p><p>为什么GitHub需要SSH Key呢？  </p><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送</p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>1.在github上创建空仓库</p><p>2.关联本地仓库与远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:youname/learngit.git</span><br></pre></td></tr></table></figure><p>3.初次推送本地仓库的内容到远程仓库中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 19, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (19/19), done.</span><br><span class="line">Writing objects: 100% (19/19), 13.73 KiB, done.</span><br><span class="line">Total 23 (delta 6), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master set up to track remote branch master from origin.</span><br></pre></td></tr></table></figure><p>4.往后的每次推送<code>$ git push origin master</code></p><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><p>第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>输入yes回车即可。</p><h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p><code>git clone</code>克隆一个本地库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/username/gitTest.git</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支作用：</p><blockquote><p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p></blockquote><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：  </p><p><img src="https://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0" alt="image">    </p><p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：  </p><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/001384908811773187a597e2d844eefb11f5cf5d56135ca000/0" alt="image"></p><p>Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/0013849088235627813efe7649b4f008900e5365bb72323000/0" alt="image"></p><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： </p><p><img src="https://www.liaoxuefeng.com/files/attachments/00138490883510324231a837e5d4aee844d3e4692ba50f5000/0" alt="image"> </p><p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><p>创建dev分支，然后切换到dev分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上-b参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p>用<code>git branch</code>命令查看当前分支：<br>*号为当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>git merge命令用于合并指定分支到当前分支。所以合并前先切换需要合并的分支之外的分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>Fast-forward 表示是快速合并</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was fec145a).</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Git鼓励大量使用分支：</span><br><span class="line"></span><br><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="合并分支的冲突处理"><a href="#合并分支的冲突处理" class="headerlink" title="合并分支的冲突处理"></a>合并分支的冲突处理</h2><p>合并分支时如果有冲突，在当前分支修改后提交，删除要合并的分支</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;git和svn的区别&quot;&gt;&lt;a href=&quot;#git和svn的区别&quot; class=&quot;headerlink&quot; title=&quot;git和svn的区别&quot;&gt;&lt;/a&gt;git和svn的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SVN、cvs集中式的版本控制系统  &lt;/li&gt;
&lt;li&gt;Git是分布式版本控制系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;git安装&quot;&gt;&lt;a href=&quot;#git安装&quot; class=&quot;headerlink&quot; title=&quot;git安装&quot;&gt;&lt;/a&gt;git安装&lt;/h2&gt;&lt;p&gt;Linux 尝试输入git可查看是否安装，如果未安装按照提示安装&lt;/p&gt;
&lt;p&gt;windows直接官网下桌面版&lt;/p&gt;
&lt;p&gt;安装完成后，还需要最后一步设置，在命令行输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name &amp;quot;Your Name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email &amp;quot;email@example.com&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Git" scheme="http://struy.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github pages搭建静态博客</title>
    <link href="http://struy.cn/2017/09/01/hexo+github%20pages%20blog/"/>
    <id>http://struy.cn/2017/09/01/hexo+github%20pages%20blog/</id>
    <published>2017-08-31T23:44:46.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li></ol><span id="more"></span>  <h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>有一个github账号</li><li>安装了node.js、npm，并了解相关基础知识；</li><li>安装了git for windows（或者其它git客户端）</li></ul><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>node作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。<br>git作用：把本地的hexo内容提交到github上去</p><h3 id="在github上搭建github-pages"><a href="#在github上搭建github-pages" class="headerlink" title="在github上搭建github pages"></a>在github上搭建github pages</h3><ul><li>新建一个名为<code>你的用户名.github.io</code>的仓库</li><li>之后的博客就存放于此</li></ul><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下<code>你的用户名.github.io</code>的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向<code>你的用户名.github.io</code>，这样可以保证无论是否添加www都可以访问，如下：</p><p><img src="http://img.struy.cn/17-9-2/43028527.jpg"></p><h3 id="配置本机的ssh-key-git"><a href="#配置本机的ssh-key-git" class="headerlink" title="配置本机的ssh key(git)"></a>配置本机的ssh key(git)</h3><h3 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h3><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><p>官网： <a href="http://hexo.io/">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="http://img.struy.cn/17-9-2/40428070.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g || hexo generate <span class="comment"># 生成静态页面</span></span><br><span class="line">$ hexo s || hexo server  <span class="comment"># 启动服务本地预览</span></span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="http://img.struy.cn/17-9-2/94846888.jpg"></p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a></p><h3 id="关联github-pages"><a href="#关联github-pages" class="headerlink" title="关联github pages"></a>关联github pages</h3><p>打开博客根目录下的<code>_config.yml</code>文件,在最下方找到并照如下修改:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/StruggleYang/StruggleYang.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>执行命令，自动使用git部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>在浏览器输入<code>user_name.github.io</code>,比如：</p><p><a href="http://struggleyang.github.io/">http://struggleyang.github.io</a></p><p>user_name是对应的github用户名</p><h3 id="以后的部署，按照以下三个步骤："><a href="#以后的部署，按照以下三个步骤：" class="headerlink" title="以后的部署，按照以下三个步骤："></a>以后的部署，按照以下三个步骤：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  #清理public下的文件,建议使用，有时候不清理页面不生效</span><br><span class="line">hexo generate #生成静态文件</span><br><span class="line">hexo deploy #部署已经生成的静态文件</span><br></pre></td></tr></table></figure><h3 id="说个问题"><a href="#说个问题" class="headerlink" title="说个问题"></a>说个问题</h3><ul><li>为了保证访问，在绑定域名时对应的CNAME类型记录需要单独建立文件存放在网站根目录，CNAME放在source里面。</li><li>在之后的操作中每次更新文章都需要部署，所以有可能将CNAME文件被新版本清除</li></ul><h3 id="一些常用hexo命令："><a href="#一些常用hexo命令：" class="headerlink" title="一些常用hexo命令："></a>一些常用hexo命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo help  #查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><h3 id="一些可能用的路径"><a href="#一些可能用的路径" class="headerlink" title="一些可能用的路径:"></a>一些可能用的路径:</h3><p>文章在 source&#x2F;_posts，编辑器可以用 Sublime，vscode，atom，有道云笔记，支持 markdown 语法。如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里，修改名字在 public&#x2F;index.html 里修改</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;使用github pages服务搭建博客的好处有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全是静态文件，访问速度快；&lt;/li&gt;
&lt;li&gt;免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;/li&gt;
&lt;li&gt;可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;/li&gt;
&lt;li&gt;数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；&lt;/li&gt;
&lt;li&gt;博客内容可以轻松打包、转移、发布到其它平台；&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="http://struy.cn/tags/Hexo/"/>
    
    <category term="GithubPages" scheme="http://struy.cn/tags/GithubPages/"/>
    
  </entry>
  
  <entry>
    <title>安装Linux后我都做了哪些事？</title>
    <link href="http://struy.cn/2017/07/10/installed%20Linux%20more/"/>
    <id>http://struy.cn/2017/07/10/installed%20Linux%20more/</id>
    <published>2017-07-10T15:18:46.000Z</published>
    <updated>2023-04-25T00:32:10.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在使用了一段时间的Linux后，前前后后安装也有几十次，也犯过一些致命的错误，为了下次不再到处翻文档，现总结一些安装后必备的东西以及常用软件及操作，以便日后查阅！    </p></blockquote><span id="more"></span><p>备注一下：  </p><p><strong>注意:请先阅读一遍全文后再操作，适用发行版为Ubuntu16.04及基于Ubuntu16.04构建的发行版，其他发行版部分相同或类似，不保证所有发行版的适用，其余发行版请自行Google对应教程，望悉知</strong>  </p><p><strong>发行版：elementary OS 0.4.1 Loki（基于 “Ubuntu 16.04.2 LTS” 构建）</strong></p><p><img src="http://img.struy.cn/17-5-30/29786706.jpg"></p><p><strong>警告:慎用rm命令，特别是root下的rm，或者带有-rf指令的rm</strong></p><h2 id="关于安装-Windows-10-elementary-OS-："><a href="#关于安装-Windows-10-elementary-OS-：" class="headerlink" title="关于安装(Windows 10 + elementary OS)："></a>关于安装(Windows 10 + elementary OS)：</h2><ul><li>对于安装而和ubuntu类似，大致有如下几个过程(只有大体过程，具体请自行百度)<ul><li>在win下用磁盘工具压缩出大致最小50G的盘(不格式化)</li><li>刻录发行版镜像到u盘(推荐‘软碟通’)</li><li>修改bios的启动(据电脑不同)</li><li>u盘启动进入安装，按照流程走就是了</li><li>重要的事是对于分区的选项，我大致是<ul><li>&#x2F;boot- -逻辑 –400M</li><li>&#x2F; - -逻辑 –20G(因为&#x2F;usr没有单独挂载，所以稍微大点)</li><li>swap –逻辑 –2G</li><li>&#x2F;home –逻辑 –剩余全部</li></ul></li><li>安装完之后重启，会没有启动选项，进入win用esayBCD进行引导的修复添加</li></ul></li><li>以上事大致过程，并非教程，仅参考</li></ul><h2 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h2><ul><li>进入系统做的第一件事情事联网，此发行版有很多驱动支持，并且基本都是可用的，不管事wifi还是以太，有了网络之后，你能做的事情就多了</li><li>联网后的第一件事情，安装系统更新：（因为考虑到速度尝试在这里找了国内的数据源进行替换，但是来更新数据源后很多东西找不到或者依赖有问题于是换了回来,所以建议使用默认源）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get update</span><br><span class="line"># sudo apt-get upgrade</span><br><span class="line"># sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure><p> 上面的东西执行起来速度可能会很慢，但是这样的过程不会经常出现<br> 在商店对一些软件进行更新，并且安装显卡驱动等等，这些都是可视化的简单操作，这里不再累述</p><h2 id="一些常见问题"><a href="#一些常见问题" class="headerlink" title="一些常见问题"></a>一些常见问题</h2><p> 安装系统更新后你可能想安装一些软件了，但是我觉得你有必要进行如下的一些操作：</p><ul><li>这个是一个很常见的问题，win与linux的时间同步问题，大致就是时间相差7小时，现将这些杂碎的问题解决，再开始构建系统的应用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># timedatectl set-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure><p> 有可能在第一次安装后执行此操作无效，你可以多试几次并重启</p><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><p>为什么要安装vim，虽然系统已经有vi，但是易用性不是很强，vim是个不错的选择，而且对vi完全兼容，后面的操作里需要有它，所以先将他安装了，方便后面操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get vim</span><br></pre></td></tr></table></figure><p>vim的三种模式：</p><ul><li>一般模式（默认进入就是一般模式,一般模式时文件只读）</li><li>编辑模式（键盘‘i’键可进入，可以编辑文件，还有其他键【o, O, a, A, r, R】，ESC可退出）</li><li>命令模式（【 : &#x2F; ? 】可进入，常见指令有q[退出]q![强制退出]wq[保存并退出]，其他的自行百度或者Google）</li></ul><h2 id="开机自动挂载ntfs磁盘"><a href="#开机自动挂载ntfs磁盘" class="headerlink" title="开机自动挂载ntfs磁盘"></a>开机自动挂载ntfs磁盘</h2><p>为什么要开机挂载磁盘？<br>假设一个场景，在某应用不得不需要引用windows的磁盘文件时，每次都会提示找不到路径，那你不得不在文件管理器中将其挂载。为了一劳永逸，并减少不必要的操作。所以建议此步执行，而这个挂载路径的方法使用于部分发行版但又有所不同，如Centos7系列的挂载可能需要安装NTFS3等等操作，具体内容还请Google。</p><p>挂载磁盘的基本思路事找到win下对应磁盘的设备号,将其<br>查看磁盘号，找到type为ntfs磁盘对应的设备号，再根据设备的具体类型大小和LABEL来找到平常对应的挂载路径，再修改设置使其长期挂载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo fdisk -l</span><br></pre></td></tr></table></figure><p>下面是我的磁盘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: 465.8 GiB, 500107862016 bytes, 976773168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x98eae607</span><br><span class="line">设备       启动     Start    末尾    扇区   Size Id 类型</span><br><span class="line">/dev/sda1  *           63 125837144 125837082    60G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda2       125837310 976771071 850933762 405.8G  f W95 扩展 (LBA)</span><br><span class="line">/dev/sda5       125837312 335552511 209715200   100G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda6       335552576 671096768 335544193   160G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda7       671100928 850939903 179838976  85.8G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda8       850941952 890939391  39997440  19.1G 83 Linux</span><br><span class="line">/dev/sda9       890941440 891719679    778240   380M 83 Linux</span><br><span class="line">/dev/sda10      891721728 893720575   1998848   976M 82 Linux 交换 / Solaris</span><br><span class="line">/dev/sda11      893722624 976771071  83048448  39.6G 83 Linux</span><br></pre></td></tr></table></figure><p>如现sda1,5,6,7根据大小可以判断其分别对应的win下C,D,E,F盘，并且最后可看出类型事ntfs格式磁盘<br>现查看磁盘的id及挂载名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo blkid</span><br></pre></td></tr></table></figure><p>结果  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1: UUID=&quot;8E5691D85691C17F&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;98eae607-01&quot;</span><br><span class="line">/dev/sda5: LABEL=&quot;Apps&quot; UUID=&quot;20869BF2869BC6A6&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;98eae607-05&quot;</span><br><span class="line">/dev/sda6: LABEL=&quot;Docs&quot; UUID=&quot;A040A29940A275A6&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;98eae607-06&quot;</span><br><span class="line">/dev/sda7: LABEL=&quot;Project&quot; UUID=&quot;0A38BD1838BD042B&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;98eae607-07&quot;</span><br><span class="line">/dev/sda8: UUID=&quot;2a816ddd-f925-442c-8b4c-cc7fd76545b9&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;98eae607-08&quot;</span><br><span class="line">/dev/sda9: UUID=&quot;74e2bc02-59fc-4517-ae95-18ec46541d9d&quot; TYPE=&quot;ext4&quot; PTTYPE=&quot;dos&quot; PARTUUID=&quot;98eae607-09&quot;</span><br><span class="line">/dev/sda10: UUID=&quot;eb8aded8-9282-426e-9b86-7333bde0d0fe&quot; TYPE=&quot;swap&quot; PARTUUID=&quot;98eae607-0a&quot;</span><br><span class="line">/dev/sda11: UUID=&quot;421078a4-af25-4fa4-a474-b250e0943c0e&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;98eae607-0b&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo vim /etc/fstab</span><br></pre></td></tr></table></figure><p>i进入插入模式在后面添加：<br>注：sy是我的用户名，在media文件夹下你也可以看到你对应的文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># disk for Windows10</span><br><span class="line"># c:  for windows10</span><br><span class="line">#/dev/sda1       /media/sy/System                ntfs    defaults        0       0</span><br><span class="line"># D:  for windows10</span><br><span class="line">/dev/sda5       /media/sy/Apps                  ntfs    defaults        0       0</span><br><span class="line"># E:  for windows10</span><br><span class="line">/dev/sda6       /media/sy/Docs                     ntfs    defaults        0       0</span><br><span class="line"># F:  for windows10</span><br><span class="line">/dev/sda7       /media/sy/Project                  ntfs    defaults        0       0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面有三个磁盘挂载，C盘我不希望（怕误删了windows下的重要文件）自动挂载所以给注释了。而每个磁盘对应着六个参数其意思分别是：（从左到右）</p><ul><li><code>&lt;file system&gt;</code> ：分区定位，可以给磁盘号，UUID或LABEL，例如：&#x2F;dev&#x2F;sda2，UUID&#x3D;6E9ADAC29ADA85CD或LABEL&#x3D;Docs</li><li><code>&lt;mount point&gt;</code> : 具体挂载点的位置，例如：&#x2F;media&#x2F;userName&#x2F;C</li><li><code>&lt;type&gt;</code> : 挂载磁盘类型，linux分区一般为ext4，windows分区一般为ntfs</li><li><code>&lt;options&gt; </code>: 挂载参数，一般为defaults</li><li><code>&lt;dump&gt;</code> : 磁盘备份，默认为0，不备份</li><li><code>&lt;pass&gt;</code>: 磁盘检查，默认为0，不检查</li></ul><blockquote><p>在这里我发现一个问题就是，NTFS对应的LABEL在windows下对应磁盘的名称，所以建议在windows下使用英文命名磁盘名称</p></blockquote><p>以上操作完成后保存并退出vim，在终端输入以下检查并挂载新添项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo mount -a</span><br></pre></td></tr></table></figure><p>mount -a会&#x2F;etc&#x2F;fstab中的项全部挂载，如果有错，则会提示错误，然后根据错误找出原因修改。</p><blockquote><p>如果说某个磁盘没有找到，先查看是否在文件管理器已经将其挂载，因为在检查时会因为没有挂载而找不到，将所有磁盘挂载后再次执行即可。</p></blockquote><p><strong>注意：千万不要挂载到当前用户的根目录，因为挂载的分区会覆盖当前分区内容,那有可能将是一个致命的操作</strong></p><h2 id="安装Gdebi以方便安装deb软件包"><a href="#安装Gdebi以方便安装deb软件包" class="headerlink" title="安装Gdebi以方便安装deb软件包"></a>安装Gdebi以方便安装deb软件包</h2><p>两中方式安装：</p><ul><li>在应用商店找到并安装</li><li>通过<code>sudo apt-get install gdebi</code>安装</li></ul><h2 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h2><p>现在的你可能需一个中文输入法对一些问题进行描述和记录，那么它来了<br>安装搜狗输入法是一个简单的过程，但是会需要安装一些依赖步骤如下：</p><ul><li>添加fcitx的键盘输入法系统，因为sogou是基于fcitx的，而系统默认的是iBus；</li><li>安装sogou输入法；</li><li>设置系统参数及一些注意点。</li></ul><p>先添加以下源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo add-apt-repository ppa:fcitx-team/nightly</span><br></pre></td></tr></table></figure><blockquote><p>如果提示源找不到依此执行安装：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install python-software-properties</span><br><span class="line"># sudo apt-get install software-properties-common</span><br><span class="line"># sudo apt-get update</span><br></pre></td></tr></table></figure><p>添加源之后需要更新一下系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get update</span><br></pre></td></tr></table></figure><p>开始安装fcitx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install fcitx</span><br></pre></td></tr></table></figure><p>下载搜狗输入法安装包（官网地址）：</p><p><a href="http://pinyin.sogou.com/linux/?r=pinyin">http://pinyin.sogou.com/linux/?r=pinyin</a><br>下载完毕在文件管理器中用Gdebi打开并安装。<br>或者在软件包对应的目录（文件名要对应修改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo gdebi sogoupinyin.deb</span><br></pre></td></tr></table></figure><h2 id="安装另一些常用软件"><a href="#安装另一些常用软件" class="headerlink" title="安装另一些常用软件"></a>安装另一些常用软件</h2><p>在这里这些常用软件都是deb包的，所以安装过程不再累述，安装只需要gdebi打开就行，或者在命令行进行安装</p><blockquote><p>还有一点注意的事，就是deb包用gdebi安装时会自动将其依赖的包下载安装，所以一些软件你不必去担心他的依赖</p></blockquote><p>下面列出常用的一些可以通过deb软件包程序安装的日常软件：</p><ul><li>Google Chrome（我只用这个浏览器）</li><li>wps（国产免费还支持Linux，支持，这样办公所需就有了）</li><li>网易云音乐（抖腿之道，唯有网易）</li><li>Aotm（前端开发很好用，不过我发现写MarkDown也很好用，此篇就是这货写的）<blockquote><p>以上软件deb包都可以在对应的官网进行下载</p></blockquote></li></ul><p>还有一些可以在应用商店下载安装的程序：</p><ul><li>FileZilla（ftp传输真的很方便）</li><li>系统监视器（日常看资源占用）</li><li>还有其他的一些自己去探索吧</li></ul><h2 id="开发环境搭建（Java-JavaWeb-Android）"><a href="#开发环境搭建（Java-JavaWeb-Android）" class="headerlink" title="开发环境搭建（Java||JavaWeb||Android）"></a>开发环境搭建（Java||JavaWeb||Android）</h2><p>上面做的只是对于日常使用而做的一些安装和配置，对于程序员来讲，要发挥桌面版的Linux的最大作用还差这些东西，现简要列出来：</p><ul><li>MySQL</li><li>JDK</li><li>Maven</li><li>Tomcat</li><li>IDEA</li><li>科学上网</li></ul><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>在ubuntu（elementary OS）下安装MySQL是一件简单的事情，只需要执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>安装过程中会让你设定两次mysql的root密码，输完请按tab键到（ok）确定，并继续</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install mysql-client</span><br><span class="line"></span><br><span class="line"># sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>安装完成后用以下命令来检验是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo netstat -tap|grep mysql</span><br></pre></td></tr></table></figure><p>通过上述命令检查后如果看到mysql的socket处于listen状态则表示安装成功</p><p>登陆mysql检验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mysql -u root -p</span><br></pre></td></tr></table></figure><p>键入刚才设置的密码以检验。</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>卸载openjdk:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get purge openjdk*</span><br></pre></td></tr></table></figure><p>官网:<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>下载官方jdk（如：jdk-8u102-linux-x64.tar.gz）<br>创建JDK存放路径。我的JDK存放在“&#x2F;usr&#x2F;jdk”，所以使用命令  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo mkdir /usr/jdk</span><br></pre></td></tr></table></figure><p>复制jdk-8u102-linux-x64.tar.gz文件到&#x2F;usr&#x2F;jdk，且使用解压缩命令“tar zxvf”解压缩  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/jdk</span><br><span class="line">// 到要存放jdk的目录(假设文件在下载目录)</span><br><span class="line"># sudo mv /home/×××/Downloads/jdk-8u102-linux-x64.tar.gz ./</span><br><span class="line">// 表示将压缩包移动到当前目录下，注意命令的目录</span><br><span class="line"># sudo tar -zxvf jdk-8u102-linux-x64.tar.gz</span><br><span class="line">// 解压到当前目录</span><br></pre></td></tr></table></figure><blockquote><p>环境变量配置:  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>这时会打开文件，在最后添加：(如果安装路径改变请对应修改)  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/jdk/jdk1.8.0_102</span><br><span class="line">export JRE_HOME=/usr/jdk/jdk1.8.0_102/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure><p>添加完成保存关闭，回到终端输入：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure><p>输入java或javac检验</p><h2 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h2><p>这个东西直接参考Maven官网就可以操作完成了  </p><p>官网地址：<a href="http://maven.apache.org/">http://maven.apache.org/</a>  </p><p>一般情况下提供tar.gz包和zip包  </p><p>安装maven的先决条件是JDK哟</p><p>假设下载下来的是tar.gz包:<code>apache-maven-3.5.0-bin.tar.gz</code><br>将其存放到你想安装的目录，在存放目录下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo tar -zxvf apache-maven-3.5.0-bin.tar.gz</span><br></pre></td></tr></table></figure><p>现假设Maven被安装在&#x2F;usr&#x2F;maven目录下：（此操作将其加入环境变量但只是暂时的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># export PATH=/usr/maven/apache-maven-3.5.0/bin:$PATH</span><br></pre></td></tr></table></figure><p>环境变量永久生效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>加入以下变量：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#maven</span><br><span class="line">export MAVEN_HOME=/usr/maven/apache-maven-3.5.0</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure><p>wq退出后刷新使环境变量生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure><p>检验安装:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><p>正确输出:(类似就行，不必一样)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)</span><br><span class="line">Maven home: /usr/maven/apache-maven-3.5.0</span><br><span class="line">Java version: 1.8.0_131, vendor: Oracle Corporation</span><br><span class="line">Java home: /usr/jdk8/jdk1.8.0_131/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;4.4.0-83-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>Tomcat安装与上面几个安装是类似的：</p><p>官网:<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a>  </p><p>下载tar.gz包，不再累述复制和解压过程，请参照以上两个解压过程</p><p>现假设下载tomcat7被解压安装到了<code>/usr/tomcat7/</code>下：</p><p>先将tomcat文件夹及子文件权限改到任意人读写执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo chmod -R a+rwx  /usr/tomcat7/*</span><br></pre></td></tr></table></figure><p>找到bin目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/tomcat7/apache-tomcat-7.0.73/bin</span><br></pre></td></tr></table></figure><p>启动:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ./startup.sh</span><br></pre></td></tr></table></figure><p>提示jdk环境问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo vim catalina.sh</span><br></pre></td></tr></table></figure><p>加入JDK的环境变量:（请相应改变）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/jdk8/jdk1.8.0_131</span><br><span class="line">export JRE_HOME=/usr/jdk8/jdk1.8.0_131/jre</span><br></pre></td></tr></table></figure><p>正确输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Using CATALINA_BASE:   /usr/tomcat7/apache-tomcat-7.0.79</span><br><span class="line">Using CATALINA_HOME:   /usr/tomcat7/apache-tomcat-7.0.79</span><br><span class="line">Using CATALINA_TMPDIR: /usr/tomcat7/apache-tomcat-7.0.79/temp</span><br><span class="line">Using JRE_HOME:        /usr/jdk8/jdk1.8.0_131/jre</span><br><span class="line">Using CLASSPATH:       /usr/tomcat7/apache-tomcat-7.0.79/bin/bootstrap.jar:/usr/tomcat7/apache-tomcat-7.0.79/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure><p>停止:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./shutdown.sh</span><br></pre></td></tr></table></figure><h2 id="安装IDEA"><a href="#安装IDEA" class="headerlink" title="安装IDEA"></a>安装IDEA</h2><p>IDEA的安装过程没有多大变化，下载解压即可使用。</p><p>官网：<a href="http://www.jetbrains.com/idea/">http://www.jetbrains.com/idea/</a>  </p><p>除了IDEA很多jetbrains家族的东西都是很好用的，在Linux平台也有很好的更新支持</p><p>如果是Android开发者，android studio也会很容易兼容此系统</p><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p><del>关于科学上网，我是用的奇影shadowsocks。一般我也用的不多，同步Chrome书签和插件时，找找Google时会用用！</del></p><h2 id="一些预览"><a href="#一些预览" class="headerlink" title="一些预览"></a>一些预览</h2><p><img src="http://img.struy.cn/17-5-30/40219153.jpg"></p><p><img src="http://img.struy.cn/17-5-30/94337476.jpg"></p><blockquote><p>还有很多有趣的东西自己去探索吧。此文为迁移博文。之前发表于&#x3D;&gt;<a href="http://blog.csdn.net/godevelop/article/details/74937795">我的CSDN</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在使用了一段时间的Linux后，前前后后安装也有几十次，也犯过一些致命的错误，为了下次不再到处翻文档，现总结一些安装后必备的东西以及常用软件及操作，以便日后查阅！    &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://struy.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
